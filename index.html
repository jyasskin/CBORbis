<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Concise Binary Object Representation (CBOR)</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Objectives">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Specification of the CBOR Encoding">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Major Types">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Indefinite Lengths for Some Major Types">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Indefinite-Length Arrays and Maps">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Indefinite-Length Byte Strings and Text Strings">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Floating-Point Numbers and Values with No Content">
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Optional Tagging of Items">
<link href="#rfc.section.2.4.1" rel="Chapter" title="2.4.1 Date and Time">
<link href="#rfc.section.2.4.2" rel="Chapter" title="2.4.2 Bignums">
<link href="#rfc.section.2.4.3" rel="Chapter" title="2.4.3 Decimal Fractions and Bigfloats">
<link href="#rfc.section.2.4.4" rel="Chapter" title="2.4.4 Content Hints">
<link href="#rfc.section.2.4.4.1" rel="Chapter" title="2.4.4.1 Encoded CBOR Data Item">
<link href="#rfc.section.2.4.4.2" rel="Chapter" title="2.4.4.2 Expected Later Encoding for CBOR-to-JSON Converters">
<link href="#rfc.section.2.4.4.3" rel="Chapter" title="2.4.4.3 Encoded Text">
<link href="#rfc.section.2.4.5" rel="Chapter" title="2.4.5 Self-Describe CBOR">
<link href="#rfc.section.3" rel="Chapter" title="3 Creating CBOR-Based Protocols">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 CBOR in Streaming Applications">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Generic Encoders and Decoders">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Syntax Errors">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Incomplete CBOR Data Items">
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 Malformed Indefinite-Length Items">
<link href="#rfc.section.3.3.3" rel="Chapter" title="3.3.3 Unknown Additional Information Values">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Other Decoding Errors">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Handling Unknown Simple Values and Tags">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Numbers">
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Specifying Keys for Maps">
<link href="#rfc.section.3.8" rel="Chapter" title="3.8 Undefined Values">
<link href="#rfc.section.3.9" rel="Chapter" title="3.9 Canonical CBOR">
<link href="#rfc.section.3.10" rel="Chapter" title="3.10 Strict Mode">
<link href="#rfc.section.4" rel="Chapter" title="4 Converting Data between CBOR and JSON">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Converting from CBOR to JSON">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Converting from JSON to CBOR">
<link href="#rfc.section.5" rel="Chapter" title="5 Future Evolution of CBOR">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Extension Points">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Curating the Additional Information Space">
<link href="#rfc.section.6" rel="Chapter" title="6 Diagnostic Notation">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Encoding Indicators">
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Simple Values Registry">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Tags Registry">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Media Type (&#8220;MIME Type&#8221;)">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 CoAP Content-Format">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 The +cbor Structured Syntax Suffix Registration">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Examples">
<link href="#rfc.appendix.B" rel="Chapter" title="B Jump Table">
<link href="#rfc.appendix.C" rel="Chapter" title="C Pseudocode">
<link href="#rfc.appendix.D" rel="Chapter" title="D Half-Precision">
<link href="#rfc.appendix.E" rel="Chapter" title="E Comparison of Other Binary Formats to CBOR&#8217;s Design Objectives">
<link href="#rfc.appendix.E.1" rel="Chapter" title="E.1 ASN.1 DER, BER, and PER">
<link href="#rfc.appendix.E.2" rel="Chapter" title="E.2 MessagePack">
<link href="#rfc.appendix.E.3" rel="Chapter" title="E.3 BSON">
<link href="#rfc.appendix.E.4" rel="Chapter" title="E.4 UBJSON">
<link href="#rfc.appendix.E.5" rel="Chapter" title="E.5 MSDTP: RFC 713">
<link href="#rfc.appendix.E.6" rel="Chapter" title="E.6 Conciseness on the Wire">
<link href="#rfc.appendix.F" rel="Chapter" title="F Changes from RFC 7049">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Bormann, C. and P. Hoffman" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-cbor-7049bis-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-9-27" />
  <meta name="dct.abstract" content="The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack." />
  <meta name="description" content="The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">C. Bormann</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Universitaet Bremen TZI</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">P. Hoffman</td>
</tr>
<tr>
<td class="left">Expires: March 31, 2018</td>
<td class="right">ICANN</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">September 27, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Concise Binary Object Representation (CBOR)<br />
  <span class="filename">draft-ietf-cbor-7049bis-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</p>
<h1><a>Contributing</a></h1>
<p>This document is being worked on in the CBOR Working Group.  Please contribute on the mailing list there, or in the GitHub repository for this draft: https://github.com/cbor-wg/CBORbis</p>
<p>The charter for the CBOR Working Group says that the WG will update RFC 7049 to fix verified errata. Security issues and clarifications may be addressed, but changes to this document will ensure backward compatibility for popular deployed codebases. This document will be targeted at becoming an Internet Standard.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 31, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Objectives</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Specification of the CBOR Encoding</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Major Types</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Indefinite Lengths for Some Major Types</a>
</li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Indefinite-Length Arrays and Maps</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Indefinite-Length Byte Strings and Text Strings</a>
</li>
</ul><li>2.3.   <a href="#rfc.section.2.3">Floating-Point Numbers and Values with No Content</a>
</li>
<li>2.4.   <a href="#rfc.section.2.4">Optional Tagging of Items</a>
</li>
<ul><li>2.4.1.   <a href="#rfc.section.2.4.1">Date and Time</a>
</li>
<li>2.4.2.   <a href="#rfc.section.2.4.2">Bignums</a>
</li>
<li>2.4.3.   <a href="#rfc.section.2.4.3">Decimal Fractions and Bigfloats</a>
</li>
<li>2.4.4.   <a href="#rfc.section.2.4.4">Content Hints</a>
</li>
<ul><li>2.4.4.1.   <a href="#rfc.section.2.4.4.1">Encoded CBOR Data Item</a>
</li>
<li>2.4.4.2.   <a href="#rfc.section.2.4.4.2">Expected Later Encoding for CBOR-to-JSON Converters</a>
</li>
<li>2.4.4.3.   <a href="#rfc.section.2.4.4.3">Encoded Text</a>
</li>
</ul><li>2.4.5.   <a href="#rfc.section.2.4.5">Self-Describe CBOR</a>
</li>
</ul></ul><li>3.   <a href="#rfc.section.3">Creating CBOR-Based Protocols</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">CBOR in Streaming Applications</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Generic Encoders and Decoders</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Syntax Errors</a>
</li>
<ul><li>3.3.1.   <a href="#rfc.section.3.3.1">Incomplete CBOR Data Items</a>
</li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">Malformed Indefinite-Length Items</a>
</li>
<li>3.3.3.   <a href="#rfc.section.3.3.3">Unknown Additional Information Values</a>
</li>
</ul><li>3.4.   <a href="#rfc.section.3.4">Other Decoding Errors</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Handling Unknown Simple Values and Tags</a>
</li>
<li>3.6.   <a href="#rfc.section.3.6">Numbers</a>
</li>
<li>3.7.   <a href="#rfc.section.3.7">Specifying Keys for Maps</a>
</li>
<li>3.8.   <a href="#rfc.section.3.8">Undefined Values</a>
</li>
<li>3.9.   <a href="#rfc.section.3.9">Canonical CBOR</a>
</li>
<li>3.10.   <a href="#rfc.section.3.10">Strict Mode</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Converting Data between CBOR and JSON</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Converting from CBOR to JSON</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Converting from JSON to CBOR</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Future Evolution of CBOR</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Extension Points</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Curating the Additional Information Space</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Diagnostic Notation</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Encoding Indicators</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">IANA Considerations</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Simple Values Registry</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Tags Registry</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Media Type (&#8220;MIME Type&#8221;)</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">CoAP Content-Format</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">The +cbor Structured Syntax Suffix Registration</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Acknowledgements</a>
</li>
<li>10.   <a href="#rfc.references">References</a>
</li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Examples</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Jump Table</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Pseudocode</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.D">Half-Precision</a>
</li>
<li>Appendix E.   <a href="#rfc.appendix.E">Comparison of Other Binary Formats to CBOR&#8217;s Design Objectives</a>
</li>
<ul><li>E.1.   <a href="#rfc.appendix.E.1">ASN.1 DER, BER, and PER</a>
</li>
<li>E.2.   <a href="#rfc.appendix.E.2">MessagePack</a>
</li>
<li>E.3.   <a href="#rfc.appendix.E.3">BSON</a>
</li>
<li>E.4.   <a href="#rfc.appendix.E.4">UBJSON</a>
</li>
<li>E.5.   <a href="#rfc.appendix.E.5">MSDTP: RFC 713</a>
</li>
<li>E.6.   <a href="#rfc.appendix.E.6">Conciseness on the Wire</a>
</li>
</ul><li>Appendix F.   <a href="#rfc.appendix.F">Changes from RFC 7049</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">There are hundreds of standardized formats for binary representation of structured data (also known as binary serialization formats).  Of those, some are for specific domains of information, while others are generalized for arbitrary data.  In the IETF, probably the best-known formats in the latter category are ASN.1&#8217;s BER and DER <a href="#ASN.1" class="xref">[ASN.1]</a>.</p>
<p id="rfc.section.1.p.2">The format defined here follows some specific design goals that are not well met by current formats.  The underlying data model is an extended version of the JSON data model <a href="#RFC7159" class="xref">[RFC7159]</a>.  It is important to note that this is not a proposal that the grammar in RFC 7159 be extended in general, since doing so would cause a significant backwards incompatibility with already deployed JSON documents. Instead, this document simply defines its own data model that starts from JSON.</p>
<p><a href="#comparison-app" class="xref">Appendix E</a> lists some existing binary formats and discusses how well they do or do not fit the design objectives of the Concise Binary Object Representation (CBOR).</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#objectives" id="objectives">Objectives</a>
</h1>
<p id="rfc.section.1.1.p.1">The objectives of CBOR, roughly in decreasing order of importance, are:</p>
<p></p>

<ol>
<li>The representation must be able to unambiguously encode most common data formats used in Internet standards.  <ul>
<li>It must represent a reasonable set of basic data types and structures using binary encoding.  &#8220;Reasonable&#8221; here is largely influenced by the capabilities of JSON, with the major addition of binary byte strings.  The structures supported are limited to arrays and trees; loops and lattice-style graphs are not supported.</li>
<li>There is no requirement that all data formats be uniquely encoded; that is, it is acceptable that the number &#8220;7&#8221; might be encoded in multiple different ways.</li>
</ul>
</li>
<li>The code for an encoder or decoder must be able to be compact in order to support systems with very limited memory, processor power, and instruction sets.  <ul>
<li>An encoder and a decoder need to be implementable in a very small amount of code (for example, in class 1 constrained nodes as defined in <a href="#RFC7228" class="xref">[RFC7228]</a>).</li>
<li>The format should use contemporary machine representations of data (for example, not requiring binary-to-decimal conversion).</li>
</ul>
</li>
<li>Data must be able to be decoded without a schema description.  <ul><li>Similar to JSON, encoded data should be self-describing so that a generic decoder can be written.</li></ul>
</li>
<li>The serialization must be reasonably compact, but data compactness is secondary to code compactness for the encoder and decoder.  <ul><li>&#8220;Reasonable&#8221; here is bounded by JSON as an upper bound in size, and by implementation complexity maintaining a lower bound.  Using either general compression schemes or extensive bit-fiddling violates the complexity goals.</li></ul>
</li>
<li>The format must be applicable to both constrained nodes and high-volume applications.  <ul><li>This means it must be reasonably frugal in CPU usage for both encoding and decoding.  This is relevant both for constrained nodes and for potential usage in applications with a very high volume of data.</li></ul>
</li>
<li>The format must support all JSON data types for conversion to and from JSON.  <ul><li>It must support a reasonable level of conversion as long as the data represented is within the capabilities of JSON.  It must be possible to define a unidirectional mapping towards JSON for all types of data.</li></ul>
</li>
<li>The format must be extensible, and the extended data must be decodable by earlier decoders.  <ul>
<li>The format is designed for decades of use.</li>
<li>The format must support a form of extensibility that allows fallback so that a decoder that does not understand an extension can still decode the message.</li>
<li>The format must be able to be extended in the future by later IETF standards.</li>
</ul>
</li>
</ol>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119, BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> and indicate requirement levels for compliant CBOR implementations.</p>
<p id="rfc.section.1.2.p.2">The term &#8220;byte&#8221; is used in its now-customary sense as a synonym for &#8220;octet&#8221;. All multi-byte values are encoded in network byte order (that is, most significant byte first, also known as &#8220;big-endian&#8221;).</p>
<p id="rfc.section.1.2.p.3">This specification makes use of the following terminology:</p>
<p></p>

<dl>
<dt>Data item:</dt>
<dd style="margin-left: 8">A single piece of CBOR data.  The structure of a data item may contain zero, one, or more nested data items.  The term is used both for the data item in representation format and for the abstract idea that can be derived from that by a decoder.</dd>
<dt>Decoder:</dt>
<dd style="margin-left: 8">A process that decodes a CBOR data item and makes it available to an application.  Formally speaking, a decoder contains a parser to break up the input using the syntax rules of CBOR, as well as a semantic processor to prepare the data in a form suitable to the application.</dd>
<dt>Encoder:</dt>
<dd style="margin-left: 8">A process that generates the representation format of a CBOR data item from application information.</dd>
<dt>Data Stream:</dt>
<dd style="margin-left: 8">A sequence of zero or more data items, not further assembled into a larger containing data item.  The independent data items that make up a data stream are sometimes also referred to as &#8220;top-level data items&#8221;.</dd>
<dt>Well-formed:</dt>
<dd style="margin-left: 8">A data item that follows the syntactic structure of CBOR.  A well-formed data item uses the initial bytes and the byte strings and/or data items that are implied by their values as defined in CBOR and is not followed by extraneous data.</dd>
<dt>Valid:</dt>
<dd style="margin-left: 8">A data item that is well-formed and also follows the semantic restrictions that apply to CBOR data items.</dd>
<dt>Stream decoder:</dt>
<dd style="margin-left: 8">A process that decodes a data stream and makes each of the data items in the sequence available to an application as they are received.</dd>
</dl>
<p id="rfc.section.1.2.p.5">Where bit arithmetic or data types are explained, this document uses the notation familiar from the programming language C, except that &#8220;**&#8221; denotes exponentiation.  Similar to the &#8220;0x&#8221; notation for hexadecimal numbers, numbers in binary notation are prefixed with &#8220;0b&#8221;.  Underscores can be added to such a number solely for readability, so 0b00100001 (0x21) might be written 0b001_00001 to emphasize the desired interpretation of the bits in the byte; in this case, it is split into three bits and five bits.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#specification-of-the-cbor-encoding" id="specification-of-the-cbor-encoding">Specification of the CBOR Encoding</a>
</h1>
<p id="rfc.section.2.p.1">A CBOR-encoded data item is structured and encoded as described in this section.  The encoding is summarized in <a href="#jumptable" class="xref">Table 5</a>.</p>
<p id="rfc.section.2.p.2">The initial byte of each data item contains both information about the major type (the high-order 3 bits, described in <a href="#majortypes" class="xref">Section 2.1</a>) and additional information (the low-order 5 bits).  When the value of the additional information is less than 24, it is directly used as a small unsigned integer.  When it is 24 to 27, the additional bytes for a variable-length integer immediately follow; the values 24 to 27 of the additional information specify that its length is a 1-, 2-, 4-, or 8-byte unsigned integer, respectively.  Additional information value 31 is used for indefinite-length items, described in <a href="#indefinite" class="xref">Section 2.2</a>.  Additional information values 28 to 30 are reserved for future expansion.</p>
<p id="rfc.section.2.p.3">In all additional information values, the resulting integer is interpreted depending on the major type.  It may represent the actual data: for example, in integer types, the resulting integer is used for the value itself.  It may instead supply length information: for example, in byte strings it gives the length of the byte string data that follows.</p>
<p id="rfc.section.2.p.4">A CBOR decoder implementation can be based on a jump table with all 256 defined values for the initial byte (<a href="#jumptable" class="xref">Table 5</a>).  A decoder in a constrained implementation can instead use the structure of the initial byte and following bytes for more compact code (see <a href="#pseudocode" class="xref">Appendix C</a> for a rough impression of how this could look).</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#majortypes" id="majortypes">Major Types</a>
</h1>
<p id="rfc.section.2.1.p.1">The following lists the major types and the additional information and other bytes associated with the type.</p>
<p></p>

<dl>
<dt>Major type 0:</dt>
<dd style="margin-left: 8">an unsigned integer. The 5-bit additional information is either the integer itself (for additional information values 0 through 23) or the length of additional data.  Additional information 24 means the value is represented in an additional uint8_t, 25 means a uint16_t, 26 means a uint32_t, and 27 means a uint64_t.  For example, the integer 10 is denoted as the one byte 0b000_01010 (major type 0, additional information 10).  The integer 500 would be 0b000_11001 (major type 0, additional information 25) followed by the two bytes 0x01f4, which is 500 in decimal.</dd>
<dt>Major type 1:</dt>
<dd style="margin-left: 8">a negative integer. The encoding follows the rules for unsigned integers (major type 0), except that the value is then -1 minus the encoded unsigned integer.  For example, the integer -500 would be 0b001_11001 (major type 1, additional information 25) followed by the two bytes 0x01f3, which is 499 in decimal.</dd>
<dt>Major type 2:</dt>
<dd style="margin-left: 8">a byte string. The string&#8217;s length in bytes is represented following the rules for positive integers (major type 0).  For example, a byte string whose length is 5 would have an initial byte of 0b010_00101 (major type 2, additional information 5 for the length), followed by 5 bytes of binary content. A byte string whose length is 500 would have 3 initial bytes of 0b010_11001 (major type 2, additional information 25 to indicate a two-byte length) followed by the two bytes 0x01f4 for a length of 500, followed by 500 bytes of binary content.</dd>
<dt>Major type 3:</dt>
<dd style="margin-left: 8">a text string, specifically a string of Unicode characters that is encoded as UTF-8 <a href="#RFC3629" class="xref">[RFC3629]</a>.  The format of this type is identical to that of byte strings (major type 2), that is, as with major type 2, the length gives the number of bytes.  This type is provided for systems that need to interpret or display human-readable text, and allows the differentiation between unstructured bytes and text that has a specified repertoire and encoding.  In contrast to formats such as JSON, the Unicode characters in this type are never escaped. Thus, a newline character (U+000A) is always represented in a string as the byte 0x0a, and never as the bytes 0x5c6e (the characters &#8220;\&#8221; and &#8220;n&#8221;) or as 0x5c7530303061 (the characters &#8220;\&#8221;, &#8220;u&#8221;, &#8220;0&#8221;, &#8220;0&#8221;, &#8220;0&#8221;, and &#8220;a&#8221;).</dd>
<dt>Major type 4:</dt>
<dd style="margin-left: 8">an array of data items.  Arrays are also called lists, sequences, or tuples.  The array&#8217;s length follows the rules for byte strings (major type 2), except that the length denotes the number of data items, not the length in bytes that the array takes up.  Items in an array do not need to all be of the same type.  For example, an array that contains 10 items of any type would have an initial byte of 0b100_01010 (major type of 4, additional information of 10 for the length) followed by the 10 remaining items.</dd>
<dt>Major type 5:</dt>
<dd style="margin-left: 8">a map of pairs of data items. Maps are also called tables, dictionaries, hashes, or objects (in JSON).  A map is comprised of pairs of data items, each pair consisting of a key that is immediately followed by a value.  The map&#8217;s length follows the rules for byte strings (major type 2), except that the length denotes the number of pairs, not the length in bytes that the map takes up.  For example, a map that contains 9 pairs would have an initial byte of 0b101_01001 (major type of 5, additional information of 9 for the number of pairs) followed by the 18 remaining items. The first item is the first key, the second item is the first value, the third item is the second key, and so on.  A map that has duplicate keys may be well-formed, but it is not valid, and thus it causes indeterminate decoding; see also <a href="#map-keys" class="xref">Section 3.7</a>.</dd>
<dt>Major type 6:</dt>
<dd style="margin-left: 8">optional semantic tagging of other major types. See <a href="#tags" class="xref">Section 2.4</a>.</dd>
<dt>Major type 7:</dt>
<dd style="margin-left: 8">floating-point numbers and simple data types that need no content, as well as the &#8220;break&#8221; stop code. See <a href="#fpnocont" class="xref">Section 2.3</a>.</dd>
</dl>
<p id="rfc.section.2.1.p.3">These eight major types lead to a simple table showing which of the 256 possible values for the initial byte of a data item are used (<a href="#jumptable" class="xref">Table 5</a>).</p>
<p id="rfc.section.2.1.p.4">In major types 6 and 7, many of the possible values are reserved for future specification. See <a href="#ianacons" class="xref">Section 7</a> for more information on these values.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#indefinite" id="indefinite">Indefinite Lengths for Some Major Types</a>
</h1>
<p id="rfc.section.2.2.p.1">Four CBOR items (arrays, maps, byte strings, and text strings) can be encoded with an indefinite length using additional information value 31.  This is useful if the encoding of the item needs to begin before the number of items inside the array or map, or the total length of the string, is known.  (The application of this is often referred to as &#8220;streaming&#8221; within a data item.)</p>
<p id="rfc.section.2.2.p.2">Indefinite-length arrays and maps are dealt with differently than indefinite-length byte strings and text strings.</p>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#indefinite-length-arrays-and-maps" id="indefinite-length-arrays-and-maps">Indefinite-Length Arrays and Maps</a>
</h1>
<p id="rfc.section.2.2.1.p.1">Indefinite-length arrays and maps are simply opened without indicating the number of data items that will be included in the array or map, using the additional information value of 31. The initial major type and additional information byte is followed by the elements of the array or map, just as they would be in other arrays or maps. The end of the array or map is indicated by encoding a &#8220;break&#8221; stop code in a place where the next data item would normally have been included.  The &#8220;break&#8221; is encoded with major type 7 and additional information value 31 (0b111_11111) but is not itself a data item: it is just a syntactic feature to close the array or map.  That is, the &#8220;break&#8221; stop code comes after the last item in the array or map, and it cannot occur anywhere else in place of a data item. In this way, indefinite-length arrays and maps look identical to other arrays and maps except for beginning with the additional information value 31 and ending with the &#8220;break&#8221; stop code.</p>
<p id="rfc.section.2.2.1.p.2">Arrays and maps with indefinite lengths allow any number of items (for arrays) and key/value pairs (for maps) to be given before the &#8220;break&#8221; stop code.  There is no restriction against nesting indefinite-length array or map items.  A &#8220;break&#8221; only terminates a single item, so nested indefinite-length items need exactly as many &#8220;break&#8221; stop codes as there are type bytes starting an indefinite-length item.</p>
<p id="rfc.section.2.2.1.p.3">For example, assume an encoder wants to represent the abstract array [1, [2, 3], [4, 5]].  The definite-length encoding would be 0x8301820203820405:</p>
<pre>
83        -- Array of length 3
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   82     -- Array of length 2
      04  -- 4
      05  -- 5
</pre>
<p id="rfc.section.2.2.1.p.4">Indefinite-length encoding could be applied independently to each of the three arrays encoded in this data item, as required, leading to representations such as:</p>
<pre>
0x9f018202039f0405ffff
9F        -- Start indefinite-length array
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   9F     -- Start indefinite-length array
      04  -- 4
      05  -- 5
      FF  -- "break" (inner array)
   FF     -- "break" (outer array)
</pre>
<pre>
0x9f01820203820405ff
9F        -- Start indefinite-length array
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   82     -- Array of length 2
      04  -- 4
      05  -- 5
   FF     -- "break"
</pre>
<pre>
0x83018202039f0405ff
83        -- Array of length 3
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   9F     -- Start indefinite-length array
      04  -- 4
      05  -- 5
      FF  -- "break"
</pre>
<pre>
0x83019f0203ff820405
83        -- Array of length 3
   01     -- 1
   9F     -- Start indefinite-length array
      02  -- 2
      03  -- 3
      FF  -- "break"
   82     -- Array of length 2
      04  -- 4
      05  -- 5
</pre>
<p id="rfc.section.2.2.1.p.5">An example of an indefinite-length map (that happens to have two key/value pairs) might be:</p>
<pre>
0xbf6346756ef563416d7421ff
BF           -- Start indefinite-length map
   63        -- First key, UTF-8 string length 3
      46756e --   "Fun"
   F5        -- First value, true
   63        -- Second key, UTF-8 string length 3
      416d74 --   "Amt"
   21        -- Second value, -2
   FF        -- "break"
</pre>
<h1 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#indefinite-length-byte-strings-and-text-strings" id="indefinite-length-byte-strings-and-text-strings">Indefinite-Length Byte Strings and Text Strings</a>
</h1>
<p id="rfc.section.2.2.2.p.1">Indefinite-length byte strings and text strings are actually a concatenation of zero or more definite-length byte or text strings (&#8220;chunks&#8221;) that are together treated as one contiguous string. Indefinite-length strings are opened with the major type and additional information value of 31, but what follows are a series of byte or text strings that have definite lengths (the chunks). The end of the series of chunks is indicated by encoding the &#8220;break&#8221; stop code (0b111_11111) in a place where the next chunk in the series would occur. The contents of the chunks are concatenated together, and the overall length of the indefinite-length string will be the sum of the lengths of all of the chunks.  In summary, an indefinite-length string is encoded similarly to how an indefinite-length array of its chunks would be encoded, except that the major type of the indefinite-length string is that of a (text or byte) string and matches the major types of its chunks.</p>
<p id="rfc.section.2.2.2.p.2">For indefinite-length byte strings, every data item (chunk) between the indefinite-length indicator and the &#8220;break&#8221; MUST be a definite-length byte string item; if the parser sees any item type other than a byte string before it sees the &#8220;break&#8221;, it is an error.</p>
<p id="rfc.section.2.2.2.p.3">For example, assume the sequence:</p>
<p id="rfc.section.2.2.2.p.4">0b010_11111 0b010_00100 0xaabbccdd 0b010_00011 0xeeff99 0b111_11111</p>
<pre>
5F              -- Start indefinite-length byte string
   44           -- Byte string of length 4
      aabbccdd  -- Bytes content
   43           -- Byte string of length 3
      eeff99    -- Bytes content
   FF           -- "break"
</pre>
<p id="rfc.section.2.2.2.p.5">After decoding, this results in a single byte string with seven bytes: 0xaabbccddeeff99.</p>
<p id="rfc.section.2.2.2.p.6">Text strings with indefinite lengths act the same as byte strings with indefinite lengths, except that all their chunks MUST be definite-length text strings.  Note that this implies that the bytes of a single UTF-8 character cannot be spread between chunks: a new chunk can only be started at a character boundary.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#fpnocont" id="fpnocont">Floating-Point Numbers and Values with No Content</a>
</h1>
<p id="rfc.section.2.3.p.1">Major type 7 is for two types of data: floating-point numbers and &#8220;simple values&#8221; that do not need any content.  Each value of the 5-bit additional information in the initial byte has its own separate meaning, as defined in <a href="#fpnoconttbl" class="xref">Table 1</a>.  Like the major types for integers, items of this major type do not carry content data; all the information is in the initial bytes.</p>
<div id="rfc.table.1"></div>
<div id="fpnoconttbl"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Values for Additional Information in Major Type 7</caption>
<thead><tr>
<th class="left">5-Bit Value</th>
<th class="left">Semantics</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0..23</td>
<td class="left">Simple value (value 0..23)</td>
</tr>
<tr>
<td class="left">24</td>
<td class="left">Simple value (value 32..255 in following byte)</td>
</tr>
<tr>
<td class="left">25</td>
<td class="left">IEEE 754 Half-Precision Float (16 bits follow)</td>
</tr>
<tr>
<td class="left">26</td>
<td class="left">IEEE 754 Single-Precision Float (32 bits follow)</td>
</tr>
<tr>
<td class="left">27</td>
<td class="left">IEEE 754 Double-Precision Float (64 bits follow)</td>
</tr>
<tr>
<td class="left">28-30</td>
<td class="left">(Unassigned)</td>
</tr>
<tr>
<td class="left">31</td>
<td class="left">&#8220;break&#8221; stop code for indefinite-length items</td>
</tr>
</tbody>
</table>
<p id="rfc.section.2.3.p.2">As with all other major types, the 5-bit value 24 signifies a single-byte extension: it is followed by an additional byte to represent the simple value. (To minimize confusion, only the values 32 to 255 are used.)  This maintains the structure of the initial bytes: as for the other major types, the length of these always depends on the additional information in the first byte. <a href="#fpnoconttbl2" class="xref">Table 2</a> lists the values assigned and available for simple types.</p>
<div id="rfc.table.2"></div>
<div id="fpnoconttbl2"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Simple Values</caption>
<thead><tr>
<th class="left">Value</th>
<th class="left">Semantics</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0..19</td>
<td class="left">(Unassigned)</td>
</tr>
<tr>
<td class="left">20</td>
<td class="left">False</td>
</tr>
<tr>
<td class="left">21</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">22</td>
<td class="left">Null</td>
</tr>
<tr>
<td class="left">23</td>
<td class="left">Undefined value</td>
</tr>
<tr>
<td class="left">24..31</td>
<td class="left">(Reserved)</td>
</tr>
<tr>
<td class="left">32..255</td>
<td class="left">(Unassigned)</td>
</tr>
</tbody>
</table>
<p id="rfc.section.2.3.p.3">The 5-bit values of 25, 26, and 27 are for 16-bit, 32-bit, and 64-bit IEEE 754 binary floating-point values.  These floating-point values are encoded in the additional bytes of the appropriate size.  (See <a href="#half-precision" class="xref">Appendix D</a> for some information about 16-bit floating point.)</p>
<h1 id="rfc.section.2.4">
<a href="#rfc.section.2.4">2.4.</a> <a href="#tags" id="tags">Optional Tagging of Items</a>
</h1>
<p id="rfc.section.2.4.p.1">In CBOR, a data item can optionally be preceded by a tag to give it additional semantics while retaining its structure. The tag is major type 6, and represents an integer number as indicated by the tag&#8217;s integer value; the (sole) data item is carried as content data.  If a tag requires structured data, this structure is encoded into the nested data item.  The definition of a tag usually restricts what kinds of nested data item or items can be carried by a tag.</p>
<p id="rfc.section.2.4.p.2">The initial bytes of the tag follow the rules for positive integers (major type 0). The tag is followed by a single data item of any type.  For example, assume that a byte string of length 12 is marked with a tag to indicate it is a positive bignum (<a href="#bignums" class="xref">Section 2.4.2</a>).  This would be marked as 0b110_00010 (major type 6, additional information 2 for the tag) followed by 0b010_01100 (major type 2, additional information of 12 for the length) followed by the 12 bytes of the bignum.</p>
<p id="rfc.section.2.4.p.3">Decoders do not need to understand tags, and thus tags may be of little value in applications where the implementation creating a particular CBOR data item and the implementation decoding that stream know the semantic meaning of each item in the data flow. Their primary purpose in this specification is to define common data types such as dates. A secondary purpose is to allow optional tagging when the decoder is a generic CBOR decoder that might be able to benefit from hints about the content of items.  Understanding the semantic tags is optional for a decoder; it can just jump over the initial bytes of the tag and interpret the tagged data item itself.</p>
<p id="rfc.section.2.4.p.4">A tag always applies to the item that is directly followed by it.  Thus, if tag A is followed by tag B, which is followed by data item C, tag A applies to the result of applying tag B on data item C.  That is, a tagged item is a data item consisting of a tag and a value.  The content of the tagged item is the data item (the value) that is being tagged.</p>
<p id="rfc.section.2.4.p.5">IANA maintains a registry of tag values as described in <a href="#ianatags" class="xref">Section 7.2</a>.  <a href="#tagvalues" class="xref">Table 3</a> provides a list of initial values, with definitions in the rest of this section.</p>
<div id="rfc.table.3"></div>
<div id="tagvalues"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Values for Tags</caption>
<thead><tr>
<th class="left">Tag</th>
<th class="left">Data Item</th>
<th class="left">Semantics</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0</td>
<td class="left">UTF-8 string</td>
<td class="left">Standard date/time string; see <a href="#datetimesect" class="xref">Section 2.4.1</a>
</td>
</tr>
<tr>
<td class="left">1</td>
<td class="left">multiple</td>
<td class="left">Epoch-based date/time; see <a href="#datetimesect" class="xref">Section 2.4.1</a>
</td>
</tr>
<tr>
<td class="left">2</td>
<td class="left">byte string</td>
<td class="left">Positive bignum; see <a href="#bignums" class="xref">Section 2.4.2</a>
</td>
</tr>
<tr>
<td class="left">3</td>
<td class="left">byte string</td>
<td class="left">Negative bignum; see <a href="#bignums" class="xref">Section 2.4.2</a>
</td>
</tr>
<tr>
<td class="left">4</td>
<td class="left">array</td>
<td class="left">Decimal fraction; see <a href="#fractions" class="xref">Section 2.4.3</a>
</td>
</tr>
<tr>
<td class="left">5</td>
<td class="left">array</td>
<td class="left">Bigfloat; see <a href="#fractions" class="xref">Section 2.4.3</a>
</td>
</tr>
<tr>
<td class="left">6..20</td>
<td class="left">(Unassigned)</td>
<td class="left">(Unassigned)</td>
</tr>
<tr>
<td class="left">21</td>
<td class="left">multiple</td>
<td class="left">Expected conversion to base64url encoding; see <a href="#convexpect" class="xref">Section 2.4.4.2</a>
</td>
</tr>
<tr>
<td class="left">22</td>
<td class="left">multiple</td>
<td class="left">Expected conversion to base64 encoding; see <a href="#convexpect" class="xref">Section 2.4.4.2</a>
</td>
</tr>
<tr>
<td class="left">23</td>
<td class="left">multiple</td>
<td class="left">Expected conversion to base16 encoding; see <a href="#convexpect" class="xref">Section 2.4.4.2</a>
</td>
</tr>
<tr>
<td class="left">24</td>
<td class="left">byte string</td>
<td class="left">Encoded CBOR data item; see <a href="#embedded-di" class="xref">Section 2.4.4.1</a>
</td>
</tr>
<tr>
<td class="left">25..31</td>
<td class="left">(Unassigned)</td>
<td class="left">(Unassigned)</td>
</tr>
<tr>
<td class="left">32</td>
<td class="left">UTF-8 string</td>
<td class="left">URI; see <a href="#encodedtext" class="xref">Section 2.4.4.3</a>
</td>
</tr>
<tr>
<td class="left">33</td>
<td class="left">UTF-8 string</td>
<td class="left">base64url; see <a href="#encodedtext" class="xref">Section 2.4.4.3</a>
</td>
</tr>
<tr>
<td class="left">34</td>
<td class="left">UTF-8 string</td>
<td class="left">base64; see <a href="#encodedtext" class="xref">Section 2.4.4.3</a>
</td>
</tr>
<tr>
<td class="left">35</td>
<td class="left">UTF-8 string</td>
<td class="left">Regular expression; see <a href="#encodedtext" class="xref">Section 2.4.4.3</a>
</td>
</tr>
<tr>
<td class="left">36</td>
<td class="left">UTF-8 string</td>
<td class="left">MIME message; see <a href="#encodedtext" class="xref">Section 2.4.4.3</a>
</td>
</tr>
<tr>
<td class="left">37..55798</td>
<td class="left">(Unassigned)</td>
<td class="left">(Unassigned)</td>
</tr>
<tr>
<td class="left">55799</td>
<td class="left">multiple</td>
<td class="left">Self-describe CBOR; see <a href="#self-describe" class="xref">Section 2.4.5</a>
</td>
</tr>
<tr>
<td class="left">55800+</td>
<td class="left">(Unassigned)</td>
<td class="left">(Unassigned)</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.2.4.1">
<a href="#rfc.section.2.4.1">2.4.1.</a> <a href="#datetimesect" id="datetimesect">Date and Time</a>
</h1>
<p id="rfc.section.2.4.1.p.1">Tag value 0 is for date/time strings that follow the standard format described in <a href="#RFC3339" class="xref">[RFC3339]</a>, as refined by Section 3.3 of <a href="#RFC4287" class="xref">[RFC4287]</a>.</p>
<p id="rfc.section.2.4.1.p.2">Tag value 1 is for numerical representation of seconds relative to 1970-01-01T00:00Z in UTC time.  (For the non-negative values that the Portable Operating System Interface (POSIX) defines, the number of seconds is counted in the same way as for POSIX &#8220;seconds since the epoch&#8221; <a href="#TIME_T" class="xref">[TIME_T]</a>.)  The tagged item can be a positive or negative integer (major types 0 and 1), or a floating-point number (major type 7 with additional information 25, 26, or 27). Note that the number can be negative (time before 1970-01-01T00:00Z) and, if a floating-point number, indicate fractional seconds.</p>
<h1 id="rfc.section.2.4.2">
<a href="#rfc.section.2.4.2">2.4.2.</a> <a href="#bignums" id="bignums">Bignums</a>
</h1>
<p id="rfc.section.2.4.2.p.1">Bignums are integers that do not fit into the basic integer representations provided by major types 0 and 1.  They are encoded as a byte string data item, which is interpreted as an unsigned integer n in network byte order.  For tag value 2, the value of the bignum is n.  For tag value 3, the value of the bignum is -1 - n.  Decoders that understand these tags MUST be able to decode bignums that have leading zeroes.</p>
<p id="rfc.section.2.4.2.p.2">For example, the number 18446744073709551616 (2**64) is represented as 0b110_00010 (major type 6, tag 2), followed by 0b010_01001 (major type 2, length 9), followed by 0x010000000000000000 (one byte 0x01 and eight bytes 0x00). In hexadecimal:</p>
<pre>
C2                        -- Tag 2
   49                     -- Byte string of length 9
      010000000000000000  -- Bytes content
</pre>
<h1 id="rfc.section.2.4.3">
<a href="#rfc.section.2.4.3">2.4.3.</a> <a href="#fractions" id="fractions">Decimal Fractions and Bigfloats</a>
</h1>
<p id="rfc.section.2.4.3.p.1">Decimal fractions combine an integer mantissa with a base-10 scaling factor.  They are most useful if an application needs the exact representation of a decimal fraction such as 1.1 because there is no exact representation for many decimal fractions in binary floating point.</p>
<p id="rfc.section.2.4.3.p.2">Bigfloats combine an integer mantissa with a base-2 scaling factor.  They are binary floating-point values that can exceed the range or the precision of the three IEEE 754 formats supported by CBOR (<a href="#fpnocont" class="xref">Section 2.3</a>).  Bigfloats may also be used by constrained applications that need some basic binary floating-point capability without the need for supporting IEEE 754.</p>
<p id="rfc.section.2.4.3.p.3">A decimal fraction or a bigfloat is represented as a tagged array that contains exactly two integer numbers: an exponent e and a mantissa m.  Decimal fractions (tag 4) use base-10 exponents; the value of a decimal fraction data item is m*(10**e).  Bigfloats (tag 5) use base-2 exponents; the value of a bigfloat data item is m*(2**e).  The exponent e MUST be represented in an integer of major type 0 or 1, while the mantissa also can be a bignum (<a href="#bignums" class="xref">Section 2.4.2</a>).</p>
<p id="rfc.section.2.4.3.p.4">An example of a decimal fraction is that the number 273.15 could be represented as 0b110_00100 (major type of 6 for the tag, additional information of 4 for the type of tag), followed by 0b100_00010 (major type of 4 for the array, additional information of 2 for the length of the array), followed by 0b001_00001 (major type of 1 for the first integer, additional information of 1 for the value of -2), followed by 0b000_11001 (major type of 0 for the second integer, additional information of 25 for a two-byte value), followed by 0b0110101010110011 (27315 in two bytes).  In hexadecimal:</p>
<pre>
C4             -- Tag 4
   82          -- Array of length 2
      21       -- -2
      19 6ab3  -- 27315
</pre>
<p id="rfc.section.2.4.3.p.5">An example of a bigfloat is that the number 1.5 could be represented as 0b110_00101 (major type of 6 for the tag, additional information of 5 for the type of tag), followed by 0b100_00010 (major type of 4 for the array, additional information of 2 for the length of the array), followed by 0b001_00000 (major type of 1 for the first integer, additional information of 0 for the value of -1), followed by 0b000_00011 (major type of 0 for the second integer, additional information of 3 for the value of 3).  In hexadecimal:</p>
<pre>
C5             -- Tag 5
   82          -- Array of length 2
      20       -- -1
      03       -- 3
</pre>
<p id="rfc.section.2.4.3.p.6">Decimal fractions and bigfloats provide no representation of Infinity, -Infinity, or NaN; if these are needed in place of a decimal fraction or bigfloat, the IEEE 754 half-precision representations from <a href="#fpnocont" class="xref">Section 2.3</a> can be used.  For constrained applications, where there is a choice between representing a specific number as an integer and as a decimal fraction or bigfloat (such as when the exponent is small and non-negative), there is a quality-of-implementation expectation that the integer representation is used directly.</p>
<h1 id="rfc.section.2.4.4">
<a href="#rfc.section.2.4.4">2.4.4.</a> <a href="#content-hints" id="content-hints">Content Hints</a>
</h1>
<p id="rfc.section.2.4.4.p.1">The tags in this section are for content hints that might be used by generic CBOR processors.</p>
<h1 id="rfc.section.2.4.4.1">
<a href="#rfc.section.2.4.4.1">2.4.4.1.</a> <a href="#embedded-di" id="embedded-di">Encoded CBOR Data Item</a>
</h1>
<p id="rfc.section.2.4.4.1.p.1">Sometimes it is beneficial to carry an embedded CBOR data item that is not meant to be decoded immediately at the time the enclosing data item is being parsed.  Tag 24 (CBOR data item) can be used to tag the embedded byte string as a data item encoded in CBOR format.</p>
<h1 id="rfc.section.2.4.4.2">
<a href="#rfc.section.2.4.4.2">2.4.4.2.</a> <a href="#convexpect" id="convexpect">Expected Later Encoding for CBOR-to-JSON Converters</a>
</h1>
<p id="rfc.section.2.4.4.2.p.1">Tags 21 to 23 indicate that a byte string might require a specific encoding when interoperating with a text-based representation.  These tags are useful when an encoder knows that the byte string data it is writing is likely to be later converted to a particular JSON-based usage. That usage specifies that some strings are encoded as base64, base64url, and so on. The encoder uses byte strings instead of doing the encoding itself to reduce the message size, to reduce the code size of the encoder, or both.  The encoder does not know whether or not the converter will be generic, and therefore wants to say what it believes is the proper way to convert binary strings to JSON.</p>
<p id="rfc.section.2.4.4.2.p.2">The data item tagged can be a byte string or any other data item.  In the latter case, the tag applies to all of the byte string data items contained in the data item, except for those contained in a nested data item tagged with an expected conversion.</p>
<p id="rfc.section.2.4.4.2.p.3">These three tag types suggest conversions to three of the base data encodings defined in <a href="#RFC4648" class="xref">[RFC4648]</a>.  For base64url encoding, padding is not used (see Section 3.2 of RFC 4648); that is, all trailing equals signs (&#8220;=&#8221;) are removed from the base64url-encoded string.  Later tags might be defined for other data encodings of RFC 4648 or for other ways to encode binary data in strings.</p>
<h1 id="rfc.section.2.4.4.3">
<a href="#rfc.section.2.4.4.3">2.4.4.3.</a> <a href="#encodedtext" id="encodedtext">Encoded Text</a>
</h1>
<p id="rfc.section.2.4.4.3.p.1">Some text strings hold data that have formats widely used on the Internet, and sometimes those formats can be validated and presented to the application in appropriate form by the decoder. There are tags for some of these formats.</p>
<p></p>

<ul>
<li>Tag 32 is for URIs, as defined in <a href="#RFC3986" class="xref">[RFC3986]</a>;</li>
<li>Tags 33 and 34 are for base64url- and base64-encoded text strings, as defined in <a href="#RFC4648" class="xref">[RFC4648]</a>;</li>
<li>Tag 35 is for regular expressions in Perl Compatible Regular Expressions (PCRE) / JavaScript syntax <a href="#ECMA262" class="xref">[ECMA262]</a>.</li>
<li>Tag 36 is for MIME messages (including all headers), as defined in <a href="#RFC2045" class="xref">[RFC2045]</a>;</li>
</ul>
<p id="rfc.section.2.4.4.3.p.3">Note that tags 33 and 34 differ from 21 and 22 in that the data is transported in base-encoded form for the former and in raw byte string form for the latter.</p>
<h1 id="rfc.section.2.4.5">
<a href="#rfc.section.2.4.5">2.4.5.</a> <a href="#self-describe" id="self-describe">Self-Describe CBOR</a>
</h1>
<p id="rfc.section.2.4.5.p.1">In many applications, it will be clear from the context that CBOR is being employed for encoding a data item.  For instance, a specific protocol might specify the use of CBOR, or a media type is indicated that specifies its use.  However, there may be applications where such context information is not available, such as when CBOR data is stored in a file and disambiguating metadata is not in use.  Here, it may help to have some distinguishing characteristics for the data itself.</p>
<p id="rfc.section.2.4.5.p.2">Tag 55799 is defined for this purpose.  It does not impart any special semantics on the data item that follows; that is, the semantics of a data item tagged with tag 55799 is exactly identical to the semantics of the data item itself.</p>
<p id="rfc.section.2.4.5.p.3">The serialization of this tag is 0xd9d9f7, which appears not to be in use as a distinguishing mark for frequently used file types.  In particular, it is not a valid start of a Unicode text in any Unicode encoding if followed by a valid CBOR data item.</p>
<p id="rfc.section.2.4.5.p.4">For instance, a decoder might be able to parse both CBOR and JSON. Such a decoder would need to mechanically distinguish the two formats. An easy way for an encoder to help the decoder would be to tag the entire CBOR item with tag 55799, the serialization of which will never be found at the beginning of a JSON text.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#creating-cbor-based-protocols" id="creating-cbor-based-protocols">Creating CBOR-Based Protocols</a>
</h1>
<p id="rfc.section.3.p.1">Data formats such as CBOR are often used in environments where there is no format negotiation. A specific design goal of CBOR is to not need any included or assumed schema: a decoder can take a CBOR item and decode it with no other knowledge.</p>
<p id="rfc.section.3.p.2">Of course, in real-world implementations, the encoder and the decoder will have a shared view of what should be in a CBOR data item.  For example, an agreed-to format might be &#8220;the item is an array whose first value is a UTF-8 string, second value is an integer, and subsequent values are zero or more floating-point numbers&#8221; or &#8220;the item is a map that has byte strings for keys and contains at least one pair whose key is 0xab01&#8221;.</p>
<p id="rfc.section.3.p.3">This specification puts no restrictions on CBOR-based protocols. An encoder can be capable of encoding as many or as few types of values as is required by the protocol in which it is used; a decoder can be capable of understanding as many or as few types of values as is required by the protocols in which it is used. This lack of restrictions allows CBOR to be used in extremely constrained environments.</p>
<p id="rfc.section.3.p.4">This section discusses some considerations in creating CBOR-based protocols.  It is advisory only and explicitly excludes any language from RFC 2119 other than words that could be interpreted as &#8220;MAY&#8221; in the sense of RFC 2119.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#cbor-in-streaming-applications" id="cbor-in-streaming-applications">CBOR in Streaming Applications</a>
</h1>
<p id="rfc.section.3.1.p.1">In a streaming application, a data stream may be composed of a sequence of CBOR data items concatenated back-to-back. In such an environment, the decoder immediately begins decoding a new data item if data is found after the end of a previous data item.</p>
<p id="rfc.section.3.1.p.2">Not all of the bytes making up a data item may be immediately available to the decoder; some decoders will buffer additional data until a complete data item can be presented to the application.  Other decoders can present partial information about a top-level data item to an application, such as the nested data items that could already be decoded, or even parts of a byte string that hasn&#8217;t completely arrived yet.</p>
<p id="rfc.section.3.1.p.3">Note that some applications and protocols will not want to use indefinite-length encoding.  Using indefinite-length encoding allows an encoder to not need to marshal all the data for counting, but it requires a decoder to allocate increasing amounts of memory while waiting for the end of the item. This might be fine for some applications but not others.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#generic" id="generic">Generic Encoders and Decoders</a>
</h1>
<p id="rfc.section.3.2.p.1">A generic CBOR decoder can decode all well-formed CBOR data and present them to an application.  CBOR data is well-formed if it uses the initial bytes, as well as the byte strings and/or data items that are implied by their values, in the manner defined by CBOR, and no extraneous data follows (<a href="#pseudocode" class="xref">Appendix C</a>).</p>
<p id="rfc.section.3.2.p.2">Even though CBOR attempts to minimize these cases, not all well-formed CBOR data is valid: for example, the format excludes simple values below 32 that are encoded with an extension byte.  Also, specific tags may make semantic constraints that may be violated, such as by including a tag in a bignum tag or by following a byte string within a date tag.  Finally, the data may be invalid, such as invalid UTF-8 strings or date strings that do not conform to <a href="#RFC3339" class="xref">[RFC3339]</a>.  There is no requirement that generic encoders and decoders make unnatural choices for their application interface to enable the processing of invalid data.  Generic encoders and decoders are expected to forward simple values and tags even if their specific codepoints are not registered at the time the encoder/decoder is written (<a href="#unknown-tags" class="xref">Section 3.5</a>).</p>
<p id="rfc.section.3.2.p.3">Generic decoders provide ways to present well-formed CBOR values, both valid and invalid, to an application.  The diagnostic notation (<a href="#diagnostic-notation" class="xref">Section 6</a>) may be used to present well-formed CBOR values to humans.</p>
<p id="rfc.section.3.2.p.4">Generic encoders provide an application interface that allows the application to specify any well-formed value, including simple values and tags unknown to the encoder.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#syntax-errors" id="syntax-errors">Syntax Errors</a>
</h1>
<p id="rfc.section.3.3.p.1">A decoder encountering a CBOR data item that is not well-formed generally can choose to completely fail the decoding (issue an error and/or stop processing altogether), substitute the problematic data and data items using a decoder-specific convention that clearly indicates there has been a problem, or take some other action.</p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#incomplete-cbor-data-items" id="incomplete-cbor-data-items">Incomplete CBOR Data Items</a>
</h1>
<p id="rfc.section.3.3.1.p.1">The representation of a CBOR data item has a specific length, determined by its initial bytes and by the structure of any data items enclosed in the data items.  If less data is available, this can be treated as a syntax error.  A decoder may also implement incremental parsing, that is, decode the data item as far as it is available and present the data found so far (such as in an event-based interface), with the option of continuing the decoding once further data is available.</p>
<p id="rfc.section.3.3.1.p.2">Examples of incomplete data items include:</p>
<p></p>

<ul>
<li>A decoder expects a certain number of array or map entries but instead encounters the end of the data.</li>
<li>A decoder processes what it expects to be the last pair in a map and comes to the end of the data.</li>
<li>A decoder has just seen a tag and then encounters the end of the data.</li>
<li>A decoder has seen the beginning of an indefinite-length item but encounters the end of the data before it sees the &#8220;break&#8221; stop code.</li>
</ul>
<h1 id="rfc.section.3.3.2">
<a href="#rfc.section.3.3.2">3.3.2.</a> <a href="#malformed-indefinite-length-items" id="malformed-indefinite-length-items">Malformed Indefinite-Length Items</a>
</h1>
<p id="rfc.section.3.3.2.p.1">Examples of malformed indefinite-length data items include:</p>
<p></p>

<ul>
<li>Within an indefinite-length byte string or text, a decoder finds an item that is not of the appropriate major type before it finds the &#8220;break&#8221; stop code.</li>
<li>Within an indefinite-length map, a decoder encounters the &#8220;break&#8221; stop code immediately after reading a key (the value is missing).</li>
</ul>
<p id="rfc.section.3.3.2.p.3">Another error is finding a &#8220;break&#8221; stop code at a point in the data where there is no immediately enclosing (unclosed) indefinite-length item.</p>
<h1 id="rfc.section.3.3.3">
<a href="#rfc.section.3.3.3">3.3.3.</a> <a href="#unknown-additional-information-values" id="unknown-additional-information-values">Unknown Additional Information Values</a>
</h1>
<p id="rfc.section.3.3.3.p.1">At the time of writing, some additional information values are unassigned and reserved for future versions of this document (see <a href="#curating" class="xref">Section 5.2</a>).  Since the overall syntax for these additional information values is not yet defined, a decoder that sees an additional information value that it does not understand cannot continue parsing.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#semantic-errors" id="semantic-errors">Other Decoding Errors</a>
</h1>
<p id="rfc.section.3.4.p.1">A CBOR data item may be syntactically well-formed but present a problem with interpreting the data encoded in it in the CBOR data model.  Generally speaking, a decoder that finds a data item with such a problem might issue a warning, might stop processing altogether, might handle the error and make the problematic value available to the application as such, or take some other type of action.</p>
<p id="rfc.section.3.4.p.2">Such problems might include:</p>
<p></p>

<dl>
<dt>Duplicate keys in a map:</dt>
<dd style="margin-left: 8">Generic decoders (<a href="#generic" class="xref">Section 3.2</a>) make data available to applications using the native CBOR data model.  That data model includes maps (key-value mappings with unique keys), not multimaps (key-value mappings where multiple entries can have the same key).  Thus, a generic decoder that gets a CBOR map item that has duplicate keys will decode to a map with only one instance of that key, or it might stop processing altogether.  On the other hand, a &#8220;streaming decoder&#8221; may not even be able to notice (<a href="#map-keys" class="xref">Section 3.7</a>).</dd>
<dt>Inadmissible type on the value following a tag:</dt>
<dd style="margin-left: 8">Tags (<a href="#tags" class="xref">Section 2.4</a>) specify what type of data item is supposed to follow the tag; for example, the tags for positive or negative bignums are supposed to be put on byte strings. A decoder that decodes the tagged data item into a native representation (a native big integer in this example) is expected to check the type of the data item being tagged.  Even decoders that don&#8217;t have such native representations available in their environment may perform the check on those tags known to them and react appropriately.</dd>
<dt>Invalid UTF-8 string:</dt>
<dd style="margin-left: 8">A decoder might or might not want to verify that the sequence of bytes in a UTF-8 string (major type 3) is actually valid UTF-8 and react appropriately.</dd>
</dl>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#unknown-tags" id="unknown-tags">Handling Unknown Simple Values and Tags</a>
</h1>
<p id="rfc.section.3.5.p.1">A decoder that comes across a simple value (<a href="#fpnocont" class="xref">Section 2.3</a>) that it does not recognize, such as a value that was added to the IANA registry after the decoder was deployed or a value that the decoder chose not to implement, might issue a warning, might stop processing altogether, might handle the error by making the unknown value available to the application as such (as is expected of generic decoders), or take some other type of action.</p>
<p id="rfc.section.3.5.p.2">A decoder that comes across a tag (<a href="#tags" class="xref">Section 2.4</a>) that it does not recognize, such as a tag that was added to the IANA registry after the decoder was deployed or a tag that the decoder chose not to implement, might issue a warning, might stop processing altogether, might handle the error and present the unknown tag value together with the contained data item to the application (as is expected of generic decoders), might ignore the tag and simply present the contained data item only to the application, or take some other type of action.</p>
<h1 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> <a href="#numbers" id="numbers">Numbers</a>
</h1>
<p id="rfc.section.3.6.p.1">For the purposes of this specification, all number representations for the same numeric value are equivalent.  This means that an encoder can encode a floating-point value of 0.0 as the integer 0.  It, however, also means that an application that expects to find integer values only might find floating-point values if the encoder decides these are desirable, such as when the floating-point value is more compact than a 64-bit integer.</p>
<p id="rfc.section.3.6.p.2">An application or protocol that uses CBOR might restrict the representations of numbers.  For instance, a protocol that only deals with integers might say that floating-point numbers may not be used and that decoders of that protocol do not need to be able to handle floating-point numbers. Similarly, a protocol or application that uses CBOR might say that decoders need to be able to handle either type of number.</p>
<p id="rfc.section.3.6.p.3">CBOR-based protocols should take into account that different language environments pose different restrictions on the range and precision of numbers that are representable.  For example, the JavaScript number system treats all numbers as floating point, which may result in silent loss of precision in decoding integers with more than 53 significant bits.  A protocol that uses numbers should define its expectations on the handling of non-trivial numbers in decoders and receiving applications.</p>
<p id="rfc.section.3.6.p.4">A CBOR-based protocol that includes floating-point numbers can restrict which of the three formats (half-precision, single-precision, and double-precision) are to be supported.  For an integer-only application, a protocol may want to completely exclude the use of floating-point values.</p>
<p id="rfc.section.3.6.p.5">A CBOR-based protocol designed for compactness may want to exclude specific integer encodings that are longer than necessary for the application, such as to save the need to implement 64-bit integers.  There is an expectation that encoders will use the most compact integer representation that can represent a given value.  However, a compact application should accept values that use a longer-than-needed encoding (such as encoding &#8220;0&#8221; as 0b000_11001 followed by two bytes of 0x00) as long as the application can decode an integer of the given size.</p>
<h1 id="rfc.section.3.7">
<a href="#rfc.section.3.7">3.7.</a> <a href="#map-keys" id="map-keys">Specifying Keys for Maps</a>
</h1>
<p id="rfc.section.3.7.p.1">The encoding and decoding applications need to agree on what types of keys are going to be used in maps.  In applications that need to interwork with JSON-based applications, keys probably should be limited to UTF-8 strings only; otherwise, there has to be a specified mapping from the other CBOR types to Unicode characters, and this often leads to implementation errors.  In applications where keys are numeric in nature and numeric ordering of keys is important to the application, directly using the numbers for the keys is useful.</p>
<p id="rfc.section.3.7.p.2">If multiple types of keys are to be used, consideration should be given to how these types would be represented in the specific programming environments that are to be used.  For example, in JavaScript objects, a key of integer 1 cannot be distinguished from a key of string &#8220;1&#8221;.  This means that, if integer keys are used, the simultaneous use of string keys that look like numbers needs to be avoided. Again, this leads to the conclusion that keys should be of a single CBOR type.</p>
<p id="rfc.section.3.7.p.3">Decoders that deliver data items nested within a CBOR data item immediately on decoding them (&#8220;streaming decoders&#8221;) often do not keep the state that is necessary to ascertain uniqueness of a key in a map.  Similarly, an encoder that can start encoding data items before the enclosing data item is completely available (&#8220;streaming encoder&#8221;) may want to reduce its overhead significantly by relying on its data source to maintain uniqueness.</p>
<p id="rfc.section.3.7.p.4">A CBOR-based protocol should make an intentional decision about what to do when a receiving application does see multiple identical keys in a map.  The resulting rule in the protocol should respect the CBOR data model: it cannot prescribe a specific handling of the entries with the identical keys, except that it might have a rule that having identical keys in a map indicates a malformed map and that the decoder has to stop with an error. Duplicate keys are also prohibited by CBOR decoders that are using strict mode (<a href="#strict-mode" class="xref">Section 3.10</a>).</p>
<p id="rfc.section.3.7.p.5">The CBOR data model for maps does not allow ascribing semantics to the order of the key/value pairs in the map representation.<br> Thus, it would be a very bad practice to define a CBOR-based protocol in such a way that changing the key/value pair order in a map would change the semantics, apart from trivial aspects (cache usage, etc.).  (A CBOR-based protocol can prescribe a specific order of serialization, such as for canonicalization.)</p>
<p id="rfc.section.3.7.p.6">Applications for constrained devices that have maps with 24 or fewer frequently used keys should consider using small integers (and those with up to 48 frequently used keys should consider also using small negative integers) because the keys can then be encoded in a single byte.</p>
<h1 id="rfc.section.3.8">
<a href="#rfc.section.3.8">3.8.</a> <a href="#undefined-values" id="undefined-values">Undefined Values</a>
</h1>
<p id="rfc.section.3.8.p.1">In some CBOR-based protocols, the simple value (<a href="#fpnocont" class="xref">Section 2.3</a>) of Undefined might be used by an encoder as a substitute for a data item with an encoding problem, in order to allow the rest of the enclosing data items to be encoded without harm.</p>
<h1 id="rfc.section.3.9">
<a href="#rfc.section.3.9">3.9.</a> <a href="#c14n" id="c14n">Canonical CBOR</a>
</h1>
<p id="rfc.section.3.9.p.1">Some protocols may want encoders to only emit CBOR in a particular canonical format; those protocols might also have the decoders check that their input is canonical. Those protocols are free to define what they mean by a canonical format and what encoders and decoders are expected to do. This section lists some suggestions for such protocols.</p>
<p id="rfc.section.3.9.p.2">If a protocol considers &#8220;canonical&#8221; to mean that two encoder implementations starting with the same input data will produce the same CBOR output, the following four rules would suffice:</p>
<p></p>

<ul>
<li>Integers must be as small as possible.  <ul>
<li>0 to 23 and -1 to -24 must be expressed in the same byte as the major type;</li>
<li>24 to 255 and -25 to -256 must be expressed only with an additional uint8_t;</li>
<li>256 to 65535 and -257 to -65536 must be expressed only with an additional uint16_t;</li>
<li>65536 to 4294967295 and -65537 to -4294967296 must be expressed only with an additional uint32_t.</li>
</ul>
</li>
<li>The expression of lengths in major types 2 through 5 must be as short as possible. The rules for these lengths follow the above rule for integers.</li>
<li>The keys in every map must be sorted lowest value to highest. Sorting is performed on the bytes of the representation of the key data items without paying attention to the 3/5 bit splitting for major types.  (Note that this rule allows maps that have keys of different types, even though that is probably a bad practice that could lead to errors in some canonicalization implementations.) The sorting rules are:  <ul>
<li>If two keys have different lengths, the shorter one sorts earlier;</li>
<li>If two keys have the same length, the one with the lower value in (byte-wise) lexical order sorts earlier.</li>
</ul>
</li>
<li>Indefinite-length items must be made into definite-length items.</li>
</ul>
<p id="rfc.section.3.9.p.4">If a protocol allows for IEEE floats, then additional canonicalization rules might need to be added.  One example rule might be to have all floats start as a 64-bit float, then do a test conversion to a 32-bit float; if the result is the same numeric value, use the shorter value and repeat the process with a test conversion to a 16-bit float. (This rule selects 16-bit float for positive and negative Infinity as well.) Also, there are many representations for NaN. If NaN is an allowed value, it must always be represented as 0xf97e00.</p>
<p id="rfc.section.3.9.p.5">CBOR tags present additional considerations for canonicalization. The absence or presence of tags in a canonical format is determined by the optionality of the tags in the protocol. In a CBOR-based protocol that allows optional tagging anywhere, the canonical format must not allow them.  In a protocol that requires tags in certain places, the tag needs to appear in the canonical format. A CBOR-based protocol that uses canonicalization might instead say that all tags that appear in a message must be retained regardless of whether they are optional.</p>
<h1 id="rfc.section.3.10">
<a href="#rfc.section.3.10">3.10.</a> <a href="#strict-mode" id="strict-mode">Strict Mode</a>
</h1>
<p id="rfc.section.3.10.p.1">Some areas of application of CBOR do not require canonicalization (<a href="#c14n" class="xref">Section 3.9</a>) but may require that different decoders reach the same (semantically equivalent) results, even in the presence of potentially malicious data.  This can be required if one application (such as a firewall or other protecting entity) makes a decision based on the data that another application, which independently decodes the data, relies on.</p>
<p id="rfc.section.3.10.p.2">Normally, it is the responsibility of the sender to avoid ambiguously decodable data.  However, the sender might be an attacker specially making up CBOR data such that it will be interpreted differently by different decoders in an attempt to exploit that as a vulnerability.  Generic decoders used in applications where this might be a problem need to support a strict mode in which it is also the responsibility of the receiver to reject ambiguously decodable data. It is expected that firewalls and other security systems that decode CBOR will only decode in strict mode.</p>
<p id="rfc.section.3.10.p.3">A decoder in strict mode will reliably reject any data that could be interpreted by other decoders in different ways.  It will reliably reject data items with syntax errors (<a href="#syntax-errors" class="xref">Section 3.3</a>).  It will also expend the effort to reliably detect other decoding errors (<a href="#semantic-errors" class="xref">Section 3.4</a>). In particular, a strict decoder needs to have an API that reports an error (and does not return data) for a CBOR data item that contains any of the following:</p>
<p></p>

<ul>
<li>a map (major type 5) that has more than one entry with the same key</li>
<li>a tag that is used on a data item of the incorrect type</li>
<li>a data item that is incorrectly formatted for the type given to it, such as invalid UTF-8 or data that cannot be interpreted with the specific tag that it has been tagged with</li>
</ul>
<p id="rfc.section.3.10.p.5">A decoder in strict mode can do one of two things when it encounters a tag or simple value that it does not recognize:</p>
<p></p>

<ul>
<li>It can report an error (and not return data).</li>
<li>It can emit the unknown item (type, value, and, for tags, the decoded tagged data item) to the application calling the decoder with an indication that the decoder did not recognize that tag or simple value.</li>
</ul>
<p id="rfc.section.3.10.p.7">The latter approach, which is also appropriate for non-strict decoders, supports forward compatibility with newly registered tags and simple values without the requirement to update the encoder at the same time as the calling application.  (For this, the API for the decoder needs to have a way to mark unknown items so that the calling application can handle them in a manner appropriate for the program.)</p>
<p id="rfc.section.3.10.p.8">Since some of this processing may have an appreciable cost (in particular with duplicate detection for maps), support of strict mode is not a requirement placed on all CBOR decoders.</p>
<p id="rfc.section.3.10.p.9">Some encoders will rely on their applications to provide input data in such a way that unambiguously decodable CBOR results.  A generic encoder also may want to provide a strict mode where it reliably limits its output to unambiguously decodable CBOR, independent of whether or not its application is providing API-conformant data.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#converting-data-between-cbor-and-json" id="converting-data-between-cbor-and-json">Converting Data between CBOR and JSON</a>
</h1>
<p id="rfc.section.4.p.1">This section gives non-normative advice about converting between CBOR and JSON. Implementations of converters are free to use whichever advice here they want.</p>
<p id="rfc.section.4.p.2">It is worth noting that a JSON text is a sequence of characters, not an encoded sequence of bytes, while a CBOR data item consists of bytes, not characters.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#converting-from-cbor-to-json" id="converting-from-cbor-to-json">Converting from CBOR to JSON</a>
</h1>
<p id="rfc.section.4.1.p.1">Most of the types in CBOR have direct analogs in JSON. However, some do not, and someone implementing a CBOR-to-JSON converter has to consider what to do in those cases. The following non-normative advice deals with these by converting them to a single substitute value, such as a JSON null.</p>
<p></p>

<ul>
<li>An integer (major type 0 or 1) becomes a JSON number.</li>
<li>A byte string (major type 2) that is not embedded in a tag that specifies a proposed encoding is encoded in base64url without padding and becomes a JSON string.</li>
<li>A UTF-8 string (major type 3) becomes a JSON string.  Note that JSON requires escaping certain characters (RFC 7159, Section 7): quotation mark (U+0022), reverse solidus (U+005C), and the &#8220;C0 control characters&#8221; (U+0000 through U+001F).  All other characters are copied unchanged into the JSON UTF-8 string.</li>
<li>An array (major type 4) becomes a JSON array.</li>
<li>A map (major type 5) becomes a JSON object.  This is possible directly only if all keys are UTF-8 strings.  A converter might also convert other keys into UTF-8 strings (such as by converting integers into strings containing their decimal representation); however, doing so introduces a danger of key collision.</li>
<li>False (major type 7, additional information 20) becomes a JSON false.</li>
<li>True (major type 7, additional information 21) becomes a JSON true.</li>
<li>Null (major type 7, additional information 22) becomes a JSON null.</li>
<li>A floating-point value (major type 7, additional information 25 through 27) becomes a JSON number if it is finite (that is, it can be represented in a JSON number); if the value is non-finite (NaN, or positive or negative Infinity), it is represented by the substitute value.</li>
<li>Any other simple value (major type 7, any additional information value not yet discussed) is represented by the substitute value.</li>
<li>A bignum (major type 6, tag value 2 or 3) is represented by encoding its byte string in base64url without padding and becomes a JSON string.  For tag value 3 (negative bignum), a &#8220;~&#8221; (ASCII tilde) is inserted before the base-encoded value. (The conversion to a binary blob instead of a number is to prevent a likely numeric overflow for the JSON decoder.)</li>
<li>A byte string with an encoding hint (major type 6, tag value 21 through 23) is encoded as described and becomes a JSON string.</li>
<li>For all other tags (major type 6, any other tag value), the embedded CBOR item is represented as a JSON value; the tag value is ignored.</li>
<li>Indefinite-length items are made definite before conversion.</li>
</ul>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#converting-from-json-to-cbor" id="converting-from-json-to-cbor">Converting from JSON to CBOR</a>
</h1>
<p id="rfc.section.4.2.p.1">All JSON values, once decoded, directly map into one or more CBOR values.  As with any kind of CBOR generation, decisions have to be made with respect to number representation.  In a suggested conversion:</p>
<p></p>

<ul>
<li>JSON numbers without fractional parts (integer numbers) are represented as integers (major types 0 and 1, possibly major type 6 tag value 2 and 3), choosing the shortest form; integers longer than an implementation-defined threshold (which is usually either 32 or 64 bits) may instead be represented as floating-point values.  (If the JSON was generated from a JavaScript implementation, its precision is already limited to 53 bits maximum.)</li>
<li>Numbers with fractional parts are represented as floating-point values.  Preferably, the shortest exact floating-point representation is used; for instance, 1.5 is represented in a 16-bit floating-point value (not all implementations will be capable of efficiently finding the minimum form, though).  There may be an implementation-defined limit to the precision that will affect the precision of the represented values. Decimal representation should only be used if that is specified in a protocol.</li>
</ul>
<p id="rfc.section.4.2.p.3">CBOR has been designed to generally provide a more compact encoding than JSON.  One implementation strategy that might come to mind is to perform a JSON-to-CBOR encoding in place in a single buffer.  This strategy would need to carefully consider a number of pathological cases, such as that some strings represented with no or very few escapes and longer (or much longer) than 255 bytes may expand when encoded as UTF-8 strings in CBOR.  Similarly, a few of the binary floating-point representations might cause expansion from some short decimal representations (1.1, 1e9) in JSON.  This may be hard to get right, and any ensuing vulnerabilities may be exploited by an attacker.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#future-evolution-of-cbor" id="future-evolution-of-cbor">Future Evolution of CBOR</a>
</h1>
<p id="rfc.section.5.p.1">Successful protocols evolve over time.  New ideas appear, implementation platforms improve, related protocols are developed and evolve, and new requirements from applications and protocols are added.  Facilitating protocol evolution is therefore an important design consideration for any protocol development.</p>
<p id="rfc.section.5.p.2">For protocols that will use CBOR, CBOR provides some useful mechanisms to facilitate their evolution.  Best practices for this are well known, particularly from JSON format development of JSON-based protocols.  Therefore, such best practices are outside the scope of this specification.</p>
<p id="rfc.section.5.p.3">However, facilitating the evolution of CBOR itself is very well within its scope.  CBOR is designed to both provide a stable basis for development of CBOR-based protocols and to be able to evolve.  Since a successful protocol may live for decades, CBOR needs to be designed for decades of use and evolution.  This section provides some guidance for the evolution of CBOR.  It is necessarily more subjective than other parts of this document.  It is also necessarily incomplete, lest it turn into a textbook on protocol development.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#extension-points" id="extension-points">Extension Points</a>
</h1>
<p id="rfc.section.5.1.p.1">In a protocol design, opportunities for evolution are often included in the form of extension points.  For example, there may be a codepoint space that is not fully allocated from the outset, and the protocol is designed to tolerate and embrace implementations that start using more codepoints than initially allocated.</p>
<p id="rfc.section.5.1.p.2">Sizing the codepoint space may be difficult because the range required may be hard to predict.  An attempt should be made to make the codepoint space large enough so that it can slowly be filled over the intended lifetime of the protocol.</p>
<p id="rfc.section.5.1.p.3">CBOR has three major extension points:</p>
<p></p>

<ul>
<li>the &#8220;simple&#8221; space (values in major type 7).  Of the 24 efficient (and 224 slightly less efficient) values, only a small number have been allocated.  Implementations receiving an unknown simple data item may be able to process it as such, given that the structure of the value is indeed simple. The IANA registry in <a href="#simple-values-registry" class="xref">Section 7.1</a> is the appropriate way to address the extensibility of this codepoint space.</li>
<li>the &#8220;tag&#8221; space (values in major type 6).  Again, only a small part of the codepoint space has been allocated, and the space is abundant (although the early numbers are more efficient than the later ones).  Implementations receiving an unknown tag can choose to simply ignore it or to process it as an unknown tag wrapping the following data item. The IANA registry in <a href="#ianatags" class="xref">Section 7.2</a> is the appropriate way to address the extensibility of this codepoint space.</li>
<li>the &#8220;additional information&#8221; space.  An implementation receiving an unknown additional information value has no way to continue parsing, so allocating codepoints to this space is a major step.  There are also very few codepoints left.</li>
</ul>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#curating" id="curating">Curating the Additional Information Space</a>
</h1>
<p id="rfc.section.5.2.p.1">The human mind is sometimes drawn to filling in little perceived gaps to make something neat.  We expect the remaining gaps in the codepoint space for the additional information values to be an attractor for new ideas, just because they are there.</p>
<p id="rfc.section.5.2.p.2">The present specification does not manage the additional information codepoint space by an IANA registry.  Instead, allocations out of this space can only be done by updating this specification.</p>
<p id="rfc.section.5.2.p.3">For an additional information value of n &gt;= 24, the size of the additional data typically is 2**(n-24) bytes.  Therefore, additional information values 28 and 29 should be viewed as candidates for 128-bit and 256-bit quantities, in case a need arises to add them to the protocol.  Additional information value 30 is then the only additional information value available for general allocation, and there should be a very good reason for allocating it before assigning it through an update of this protocol.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#diagnostic-notation" id="diagnostic-notation">Diagnostic Notation</a>
</h1>
<p id="rfc.section.6.p.1">CBOR is a binary interchange format.  To facilitate documentation and debugging, and in particular to facilitate communication between entities cooperating in debugging, this section defines a simple human-readable diagnostic notation.  All actual interchange always happens in the binary format.</p>
<p id="rfc.section.6.p.2">Note that this truly is a diagnostic format; it is not meant to be parsed.  Therefore, no formal definition (as in ABNF) is given in this document.  (Implementers looking for a text-based format for representing CBOR data items in configuration files may also want to consider YAML <a href="#YAML" class="xref">[YAML]</a>.)</p>
<p id="rfc.section.6.p.3">The diagnostic notation is loosely based on JSON as it is defined in RFC 7159, extending it where needed.</p>
<p id="rfc.section.6.p.4">The notation borrows the JSON syntax for numbers (integer and floating point), True (&gt;true&lt;), False (&gt;false&lt;), Null (&gt;null&lt;), UTF-8 strings, arrays, and maps (maps are called objects in JSON; the diagnostic notation extends JSON here by allowing any data item in the key position).  Undefined is written &gt;undefined&lt; as in JavaScript.  The non-finite floating-point numbers Infinity, -Infinity, and NaN are written exactly as in this sentence (this is also a way they can be written in JavaScript, although JSON does not allow them).  A tagged item is written as an integer number for the tag followed by the item in parentheses; for instance, an RFC 3339 (ISO 8601) date could be notated as:</p>
<p></p>

<ul class="empty"><li>0(&#8220;2013-03-21T20:04:00Z&#8221;)</li></ul>
<p id="rfc.section.6.p.6">or the equivalent relative time as</p>
<p></p>

<ul class="empty"><li>1(1363896240)</li></ul>
<p id="rfc.section.6.p.8">Byte strings are notated in one of the base encodings, without padding, enclosed in single quotes, prefixed by &gt;h&lt; for base16, &gt;b32&lt; for base32, &gt;h32&lt; for base32hex, &gt;b64&lt; for base64 or base64url (the actual encodings do not overlap, so the string remains unambiguous).  For example, the byte string 0x12345678 could be written h&#8217;12345678&#8217;, b32&#8217;CI2FM6A&#8217;, or b64&#8217;EjRWeA&#8217;.</p>
<p id="rfc.section.6.p.9">Unassigned simple values are given as &#8220;simple()&#8221; with the appropriate integer in the parentheses. For example, &#8220;simple(42)&#8221; indicates major type 7, value 42.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#encoding-indicators" id="encoding-indicators">Encoding Indicators</a>
</h1>
<p id="rfc.section.6.1.p.1">Sometimes it is useful to indicate in the diagnostic notation which of several alternative representations were actually used; for example, a data item written &gt;1.5&lt; by a diagnostic decoder might have been encoded as a half-, single-, or double-precision float.</p>
<p id="rfc.section.6.1.p.2">The convention for encoding indicators is that anything starting with an underscore and all following characters that are alphanumeric or underscore, is an encoding indicator, and can be ignored by anyone not interested in this information.  Encoding indicators are always optional.</p>
<p id="rfc.section.6.1.p.3">A single underscore can be written after the opening brace of a map or the opening bracket of an array to indicate that the data item was represented in indefinite-length format.  For example, [_ 1, 2] contains an indicator that an indefinite-length representation was used to represent the data item [1, 2].</p>
<p id="rfc.section.6.1.p.4">An underscore followed by a decimal digit n indicates that the preceding item (or, for arrays and maps, the item starting with the preceding bracket or brace) was encoded with an additional information value of 24+n.  For example, 1.5_1 is a half-precision floating-point number, while 1.5_3 is encoded as double precision.  This encoding indicator is not shown in <a href="#examples" class="xref">Appendix A</a>.  (Note that the encoding indicator &#8220;_&#8221; is thus an abbreviation of the full form &#8220;_7&#8221;, which is not used.)</p>
<p id="rfc.section.6.1.p.5">As a special case, byte and text strings of indefinite length can be notated in the form (_ h&#8217;0123&#8217;, h&#8217;4567&#8217;) and (_ &#8220;foo&#8221;, &#8220;bar&#8221;).</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#ianacons" id="ianacons">IANA Considerations</a>
</h1>
<p id="rfc.section.7.p.1">IANA has created two registries for new CBOR values. The registries are separate, that is, not under an umbrella registry, and follow the rules in <a href="#RFC5226" class="xref">[RFC5226]</a>. IANA has also assigned a new MIME media type and an associated Constrained Application Protocol (CoAP) Content-Format entry.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#simple-values-registry" id="simple-values-registry">Simple Values Registry</a>
</h1>
<p id="rfc.section.7.1.p.1">IANA has created the &#8220;Concise Binary Object Representation (CBOR) Simple Values&#8221; registry. The initial values are shown in <a href="#fpnoconttbl2" class="xref">Table 2</a>.</p>
<p id="rfc.section.7.1.p.2">New entries in the range 0 to 19 are assigned by Standards Action.  It is suggested that these Standards Actions allocate values starting with the number 16 in order to reserve the lower numbers for contiguous blocks (if any).</p>
<p id="rfc.section.7.1.p.3">New entries in the range 32 to 255 are assigned by Specification Required.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#ianatags" id="ianatags">Tags Registry</a>
</h1>
<p id="rfc.section.7.2.p.1">IANA has created the &#8220;Concise Binary Object Representation (CBOR) Tags&#8221; registry. The initial values are shown in <a href="#tagvalues" class="xref">Table 3</a>.</p>
<p id="rfc.section.7.2.p.2">New entries in the range 0 to 23 are assigned by Standards Action.  New entries in the range 24 to 255 are assigned by Specification Required.  New entries in the range 256 to 18446744073709551615 are assigned by First Come First Served. The template for registration requests is:</p>
<p></p>

<ul>
<li>Data item</li>
<li>Semantics (short form)</li>
</ul>
<p id="rfc.section.7.2.p.4">In addition, First Come First Served requests should include:</p>
<p></p>

<ul>
<li>Point of contact</li>
<li>Description of semantics (URL)<br> This description is optional; the URL can point to something like an Internet-Draft or a web page.</li>
</ul>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#media-type-mime-type" id="media-type-mime-type">Media Type (&#8220;MIME Type&#8221;)</a>
</h1>
<p id="rfc.section.7.3.p.1">The Internet media type <a href="#RFC6838" class="xref">[RFC6838]</a> for CBOR data is application/cbor.</p>
<p id="rfc.section.7.3.p.2">Type name: application</p>
<p id="rfc.section.7.3.p.3">Subtype name: cbor</p>
<p id="rfc.section.7.3.p.4">Required parameters: n/a</p>
<p id="rfc.section.7.3.p.5">Optional parameters: n/a</p>
<p></p>

<dl>
<dt>Encoding considerations:</dt>
<dd style="margin-left: 8">binary</dd>
<dt>Security considerations:</dt>
<dd style="margin-left: 8">See <a href="#securitycons" class="xref">Section 8</a> of this document</dd>
</dl>
<p id="rfc.section.7.3.p.7">Interoperability considerations: n/a</p>
<p id="rfc.section.7.3.p.8">Published specification: This document</p>
<p></p>

<dl>
<dt>Applications that use this media type:</dt>
<dd style="margin-left: 8">None yet, but it is expected that this format will be deployed in protocols and applications.</dd>
</dl>
<pre>
Additional information:
  Magic number(s): n/a
  File extension(s): .cbor
  Macintosh file type code(s): n/a

Person &amp; email address to contact for further information:
  Carsten Bormann
  cabo@tzi.org

Intended usage: COMMON

Restrictions on usage: none

Author:
  Carsten Bormann &lt;cabo@tzi.org&gt;

Change controller:
  The IESG &lt;iesg@ietf.org&gt;
</pre>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#coap-content-format" id="coap-content-format">CoAP Content-Format</a>
</h1>
<p id="rfc.section.7.4.p.1">Media Type: application/cbor</p>
<p id="rfc.section.7.4.p.2">Encoding: -</p>
<p id="rfc.section.7.4.p.3">Id: 60</p>
<p id="rfc.section.7.4.p.4">Reference: [RFCthis]</p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> <a href="#the-cbor-structured-syntax-suffix-registration" id="the-cbor-structured-syntax-suffix-registration">The +cbor Structured Syntax Suffix Registration</a>
</h1>
<p id="rfc.section.7.5.p.1">Name:  Concise Binary Object Representation (CBOR)</p>
<p id="rfc.section.7.5.p.2">+suffix: +cbor</p>
<p id="rfc.section.7.5.p.3">References: [RFCthis]</p>
<p id="rfc.section.7.5.p.4">Encoding Considerations: CBOR is a binary format.</p>
<p id="rfc.section.7.5.p.5">Interoperability Considerations: n/a</p>
<pre>
Fragment Identifier Considerations:
  The syntax and semantics of fragment identifiers specified for
  +cbor SHOULD be as specified for "application/cbor".  (At
  publication of this document, there is no fragment identification
  syntax defined for "application/cbor".)

  The syntax and semantics for fragment identifiers for a specific
  "xxx/yyy+cbor" SHOULD be processed as follows:

  For cases defined in +cbor, where the fragment identifier resolves
  per the +cbor rules, then process as specified in +cbor.

  For cases defined in +cbor, where the fragment identifier does
  not resolve per the +cbor rules, then process as specified in
  "xxx/yyy+cbor".

  For cases not defined in +cbor, then process as specified in
  "xxx/yyy+cbor".
</pre>
<p></p>

<dl>
<dt>Security Considerations:</dt>
<dd style="margin-left: 8">See <a href="#securitycons" class="xref">Section 8</a> of this document</dd>
</dl>
<pre>
Contact:
  Apps Area Working Group (apps-discuss@ietf.org)

Author/Change Controller:
  The Apps Area Working Group.
  The IESG has change control over this registration.
</pre>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#securitycons" id="securitycons">Security Considerations</a>
</h1>
<p id="rfc.section.8.p.1">A network-facing application can exhibit vulnerabilities in its processing logic for incoming data. Complex parsers are well known as a likely source of such vulnerabilities, such as the ability to remotely crash a node, or even remotely execute arbitrary code on it.  CBOR attempts to narrow the opportunities for introducing such vulnerabilities by reducing parser complexity, by giving the entire range of encodable values a meaning where possible.</p>
<p id="rfc.section.8.p.2">Resource exhaustion attacks might attempt to lure a decoder into allocating very big data items (strings, arrays, maps) or exhaust the stack depth by setting up deeply nested items.  Decoders need to have appropriate resource management to mitigate these attacks.  (Items for which very large sizes are given can also attempt to exploit integer overflow vulnerabilities.)</p>
<p id="rfc.section.8.p.3">Applications where a CBOR data item is examined by a gatekeeper function and later used by a different application may exhibit vulnerabilities when multiple interpretations of the data item are possible. For example, an attacker could make use of duplicate keys in maps and precision issues in numbers to make the gatekeeper base its decisions on a different interpretation than the one that will be used by the second application.  Protocols that are used in a security context should be defined in such a way that these multiple interpretations are reliably reduced to a single one.  To facilitate this, encoder and decoder implementations used in such contexts should provide at least one strict mode of operation (<a href="#strict-mode" class="xref">Section 3.10</a>).</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.9.p.1">CBOR was inspired by MessagePack.  MessagePack was developed and promoted by Sadayuki Furuhashi (&#8220;frsyuki&#8221;).  This reference to MessagePack is solely for attribution; CBOR is not intended as a version of or replacement for MessagePack, as it has different design goals and requirements.</p>
<p id="rfc.section.9.p.2">The need for functionality beyond the original MessagePack Specification became obvious to many people at about the same time around the year 2012.  BinaryPack is a minor derivation of MessagePack that was developed by Eric Zhang for the binaryjs project.  A similar, but different, extension was made by Tim Caswell for his msgpack-js and msgpack-js-browser projects.  Many people have contributed to the recent discussion about extending MessagePack to separate text string representation from byte string representation.</p>
<p id="rfc.section.9.p.3">The encoding of the additional information in CBOR was inspired by the encoding of length information designed by Klaus Hartke for CoAP.</p>
<p id="rfc.section.9.p.4">This document also incorporates suggestions made by many people, notably Dan Frost, James Manger, Joe Hildebrand, Keith Moore, Matthew Lepinski, Nico Williams, Phillip Hallam-Baker, Ray Polk, Tim Bray, Tony Finch, Tony Hansen, and Yaron Sheffer.</p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ECMA262">[ECMA262]</b></td>
<td class="top">
<a>European Computer Manufacturers Association</a>, "<a href="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf">ECMAScript Language Specification 5.1 Edition</a>", ECMA Standard ECMA-262, June 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2045">[RFC2045]</b></td>
<td class="top">
<a>Freed, N.</a> and <a>N. Borenstein</a>, "<a href="https://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>", RFC 2045, DOI 10.17487/RFC2045, November 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3339">[RFC3339]</b></td>
<td class="top">
<a>Klyne, G.</a> and <a>C. Newman</a>, "<a href="https://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>", RFC 3339, DOI 10.17487/RFC3339, July 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="https://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4287">[RFC4287]</b></td>
<td class="top">
<a>Nottingham, M.</a> and <a>R. Sayre</a>, "<a href="https://tools.ietf.org/html/rfc4287">The Atom Syndication Format</a>", RFC 4287, DOI 10.17487/RFC4287, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, DOI 10.17487/RFC4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5226">[RFC5226]</b></td>
<td class="top">
<a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="https://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", RFC 5226, DOI 10.17487/RFC5226, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="TIME_T">[TIME_T]</b></td>
<td class="top">
<a>The Open Group Base Specifications</a>, "<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15">Vol. 1: Base Definitions, Issue 7</a>", Section 4.15 'Seconds Since the Epoch', IEEE Std 1003.1, 2013 Edition, 2013.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ASN.1">[ASN.1]</b></td>
<td class="top">
<a>International Telecommunication Union</a>, "<a>Information Technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", ITU-T Recommendation X.690, 1994.</td>
</tr>
<tr>
<td class="reference"><b id="BSON">[BSON]</b></td>
<td class="top">
<a>Various</a>, "<a href="http://bsonspec.org/">BSON - Binary JSON</a>", 2013.</td>
</tr>
<tr>
<td class="reference"><b id="MessagePack">[MessagePack]</b></td>
<td class="top">
<a>Furuhashi, S.</a>, "<a href="http://msgpack.org/">MessagePack</a>", 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0713">[RFC0713]</b></td>
<td class="top">
<a>Haverty, J.</a>, "<a href="https://tools.ietf.org/html/rfc713">MSDTP-Message Services Data Transmission Protocol</a>", RFC 713, DOI 10.17487/RFC0713, April 1976.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6838">[RFC6838]</b></td>
<td class="top">
<a>Freed, N.</a>, <a>Klensin, J.</a> and <a>T. Hansen</a>, "<a href="https://tools.ietf.org/html/rfc6838">Media Type Specifications and Registration Procedures</a>", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7159">[RFC7159]</b></td>
<td class="top">
<a>Bray, T.</a>, "<a href="https://tools.ietf.org/html/rfc7159">The JavaScript Object Notation (JSON) Data Interchange Format</a>", RFC 7159, DOI 10.17487/RFC7159, March 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7228">[RFC7228]</b></td>
<td class="top">
<a>Bormann, C.</a>, <a>Ersue, M.</a> and <a>A. Keranen</a>, "<a href="https://tools.ietf.org/html/rfc7228">Terminology for Constrained-Node Networks</a>", RFC 7228, DOI 10.17487/RFC7228, May 2014.</td>
</tr>
<tr>
<td class="reference"><b id="UBJSON">[UBJSON]</b></td>
<td class="top">
<a>The Buzz Media</a>, "<a href="http://ubjson.org/">Universal Binary JSON Specification</a>", 2013.</td>
</tr>
<tr>
<td class="reference"><b id="YAML">[YAML]</b></td>
<td class="top">
<a>Ben-Kiki, O.</a>, <a>Evans, C.</a> and <a>I. Net</a>, "<a href="http://www.yaml.org/spec/1.2/spec.html">YAML Ain't Markup Language (YAML[TM]) Version 1.2</a>", 3rd Edition, October 2009.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#examples" id="examples">Examples</a>
</h1>
<p id="rfc.section.A.p.1">The following table provides some CBOR-encoded values in hexadecimal (right column), together with diagnostic notation for these values (left column).  Note that the string &#8220;\u00fc&#8221; is one form of diagnostic notation for a UTF-8 string containing the single Unicode character U+00FC, LATIN SMALL LETTER U WITH DIAERESIS (u umlaut).  Similarly, &#8220;\u6c34&#8221; is a UTF-8 string in diagnostic notation with a single character U+6C34 (CJK UNIFIED IDEOGRAPH-6C34, often representing &#8220;water&#8221;), and &#8220;\ud800\udd51&#8221; is a UTF-8 string in diagnostic notation with a single character U+10151 (GREEK ACROPHONIC ATTIC FIFTY STATERS).  (Note that all these single-character strings could also be represented in native UTF-8 in diagnostic notation, just not in an ASCII-only specification like the present one.)  In the diagnostic notation provided for bignums, their intended numeric value is shown as a decimal number (such as 18446744073709551616) instead of showing a tagged byte string (such as 2(h&#8217;010000000000000000&#8217;)).</p>
<div id="rfc.table.4"></div>
<div id="table_examples"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Examples of Encoded CBOR Data Items</caption>
<thead><tr>
<th class="left">Diagnostic</th>
<th class="left">Encoded</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0</td>
<td class="left">0x00</td>
</tr>
<tr>
<td class="left">1</td>
<td class="left">0x01</td>
</tr>
<tr>
<td class="left">10</td>
<td class="left">0x0a</td>
</tr>
<tr>
<td class="left">23</td>
<td class="left">0x17</td>
</tr>
<tr>
<td class="left">24</td>
<td class="left">0x1818</td>
</tr>
<tr>
<td class="left">25</td>
<td class="left">0x1819</td>
</tr>
<tr>
<td class="left">100</td>
<td class="left">0x1864</td>
</tr>
<tr>
<td class="left">1000</td>
<td class="left">0x1903e8</td>
</tr>
<tr>
<td class="left">1000000</td>
<td class="left">0x1a000f4240</td>
</tr>
<tr>
<td class="left">1000000000000</td>
<td class="left">0x1b000000e8d4a51000</td>
</tr>
<tr>
<td class="left">18446744073709551615</td>
<td class="left">0x1bffffffffffffffff</td>
</tr>
<tr>
<td class="left">18446744073709551616</td>
<td class="left">0xc249010000000000000000</td>
</tr>
<tr>
<td class="left">-18446744073709551616</td>
<td class="left">0x3bffffffffffffffff</td>
</tr>
<tr>
<td class="left">-18446744073709551617</td>
<td class="left">0xc349010000000000000000</td>
</tr>
<tr>
<td class="left">-1</td>
<td class="left">0x20</td>
</tr>
<tr>
<td class="left">-10</td>
<td class="left">0x29</td>
</tr>
<tr>
<td class="left">-100</td>
<td class="left">0x3863</td>
</tr>
<tr>
<td class="left">-1000</td>
<td class="left">0x3903e7</td>
</tr>
<tr>
<td class="left">0.0</td>
<td class="left">0xf90000</td>
</tr>
<tr>
<td class="left">-0.0</td>
<td class="left">0xf98000</td>
</tr>
<tr>
<td class="left">1.0</td>
<td class="left">0xf93c00</td>
</tr>
<tr>
<td class="left">1.1</td>
<td class="left">0xfb3ff199999999999a</td>
</tr>
<tr>
<td class="left">1.5</td>
<td class="left">0xf93e00</td>
</tr>
<tr>
<td class="left">65504.0</td>
<td class="left">0xf97bff</td>
</tr>
<tr>
<td class="left">100000.0</td>
<td class="left">0xfa47c35000</td>
</tr>
<tr>
<td class="left">3.4028234663852886e+38</td>
<td class="left">0xfa7f7fffff</td>
</tr>
<tr>
<td class="left">1.0e+300</td>
<td class="left">0xfb7e37e43c8800759c</td>
</tr>
<tr>
<td class="left">5.960464477539063e-8</td>
<td class="left">0xf90001</td>
</tr>
<tr>
<td class="left">0.00006103515625</td>
<td class="left">0xf90400</td>
</tr>
<tr>
<td class="left">-4.0</td>
<td class="left">0xf9c400</td>
</tr>
<tr>
<td class="left">-4.1</td>
<td class="left">0xfbc010666666666666</td>
</tr>
<tr>
<td class="left">Infinity</td>
<td class="left">0xf97c00</td>
</tr>
<tr>
<td class="left">NaN</td>
<td class="left">0xf97e00</td>
</tr>
<tr>
<td class="left">-Infinity</td>
<td class="left">0xf9fc00</td>
</tr>
<tr>
<td class="left">Infinity</td>
<td class="left">0xfa7f800000</td>
</tr>
<tr>
<td class="left">NaN</td>
<td class="left">0xfa7fc00000</td>
</tr>
<tr>
<td class="left">-Infinity</td>
<td class="left">0xfaff800000</td>
</tr>
<tr>
<td class="left">Infinity</td>
<td class="left">0xfb7ff0000000000000</td>
</tr>
<tr>
<td class="left">NaN</td>
<td class="left">0xfb7ff8000000000000</td>
</tr>
<tr>
<td class="left">-Infinity</td>
<td class="left">0xfbfff0000000000000</td>
</tr>
<tr>
<td class="left">false</td>
<td class="left">0xf4</td>
</tr>
<tr>
<td class="left">true</td>
<td class="left">0xf5</td>
</tr>
<tr>
<td class="left">null</td>
<td class="left">0xf6</td>
</tr>
<tr>
<td class="left">undefined</td>
<td class="left">0xf7</td>
</tr>
<tr>
<td class="left">simple(16)</td>
<td class="left">0xf0</td>
</tr>
<tr>
<td class="left">simple(24)</td>
<td class="left">0xf818</td>
</tr>
<tr>
<td class="left">simple(255)</td>
<td class="left">0xf8ff</td>
</tr>
<tr>
<td class="left">0(&#8220;2013-03-21T20:04:00Z&#8221;)</td>
<td class="left">0xc074323031332d30332d32315432303a 30343a30305a</td>
</tr>
<tr>
<td class="left">1(1363896240)</td>
<td class="left">0xc11a514b67b0</td>
</tr>
<tr>
<td class="left">1(1363896240.5)</td>
<td class="left">0xc1fb41d452d9ec200000</td>
</tr>
<tr>
<td class="left">23(h&#8217;01020304&#8217;)</td>
<td class="left">0xd74401020304</td>
</tr>
<tr>
<td class="left">24(h&#8217;6449455446&#8217;)</td>
<td class="left">0xd818456449455446</td>
</tr>
<tr>
<td class="left">32(&#8220;http://www.example.com&#8221;)</td>
<td class="left">0xd82076687474703a2f2f7777772e6578 616d706c652e636f6d</td>
</tr>
<tr>
<td class="left">h&#8217;&#8217;</td>
<td class="left">0x40</td>
</tr>
<tr>
<td class="left">h&#8217;01020304&#8217;</td>
<td class="left">0x4401020304</td>
</tr>
<tr>
<td class="left">&#8221;&#8221;</td>
<td class="left">0x60</td>
</tr>
<tr>
<td class="left">&#8220;a&#8221;</td>
<td class="left">0x6161</td>
</tr>
<tr>
<td class="left">&#8220;IETF&#8221;</td>
<td class="left">0x6449455446</td>
</tr>
<tr>
<td class="left">&#8221;\&#8221;\\&#8221;</td>
<td class="left">0x62225c</td>
</tr>
<tr>
<td class="left">&#8220;\u00fc&#8221;</td>
<td class="left">0x62c3bc</td>
</tr>
<tr>
<td class="left">&#8220;\u6c34&#8221;</td>
<td class="left">0x63e6b0b4</td>
</tr>
<tr>
<td class="left">&#8220;\ud800\udd51&#8221;</td>
<td class="left">0x64f0908591</td>
</tr>
<tr>
<td class="left">[]</td>
<td class="left">0x80</td>
</tr>
<tr>
<td class="left">[1, 2, 3]</td>
<td class="left">0x83010203</td>
</tr>
<tr>
<td class="left">[1, [2, 3], [4, 5]]</td>
<td class="left">0x8301820203820405</td>
</tr>
<tr>
<td class="left">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]</td>
<td class="left">0x98190102030405060708090a0b0c0d0e 0f101112131415161718181819</td>
</tr>
<tr>
<td class="left">{}</td>
<td class="left">0xa0</td>
</tr>
<tr>
<td class="left">{1: 2, 3: 4}</td>
<td class="left">0xa201020304</td>
</tr>
<tr>
<td class="left">{&#8220;a&#8221;: 1, &#8220;b&#8221;: [2, 3]}</td>
<td class="left">0xa26161016162820203</td>
</tr>
<tr>
<td class="left">[&#8220;a&#8221;, {&#8220;b&#8221;: &#8220;c&#8221;}]</td>
<td class="left">0x826161a161626163</td>
</tr>
<tr>
<td class="left">{&#8220;a&#8221;: &#8220;A&#8221;, &#8220;b&#8221;: &#8220;B&#8221;, &#8220;c&#8221;: &#8220;C&#8221;, &#8220;d&#8221;: &#8220;D&#8221;, &#8220;e&#8221;: &#8220;E&#8221;}</td>
<td class="left">0xa5616161416162614261636143616461 4461656145</td>
</tr>
<tr>
<td class="left">(_ h&#8217;0102&#8217;, h&#8217;030405&#8217;)</td>
<td class="left">0x5f42010243030405ff</td>
</tr>
<tr>
<td class="left">(_ &#8220;strea&#8221;, &#8220;ming&#8221;)</td>
<td class="left">0x7f657374726561646d696e67ff</td>
</tr>
<tr>
<td class="left">[_ ]</td>
<td class="left">0x9fff</td>
</tr>
<tr>
<td class="left">[_ 1, [2, 3], [_ 4, 5]]</td>
<td class="left">0x9f018202039f0405ffff</td>
</tr>
<tr>
<td class="left">[_ 1, [2, 3], [4, 5]]</td>
<td class="left">0x9f01820203820405ff</td>
</tr>
<tr>
<td class="left">[1, [2, 3], [_ 4, 5]]</td>
<td class="left">0x83018202039f0405ff</td>
</tr>
<tr>
<td class="left">[1, [_ 2, 3], [4, 5]]</td>
<td class="left">0x83019f0203ff820405</td>
</tr>
<tr>
<td class="left">[_ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]</td>
<td class="left">0x9f0102030405060708090a0b0c0d0e0f 101112131415161718181819ff</td>
</tr>
<tr>
<td class="left">{_ &#8220;a&#8221;: 1, &#8220;b&#8221;: [_ 2, 3]}</td>
<td class="left">0xbf61610161629f0203ffff</td>
</tr>
<tr>
<td class="left">[&#8220;a&#8221;, {_ &#8220;b&#8221;: &#8220;c&#8221;}]</td>
<td class="left">0x826161bf61626163ff</td>
</tr>
<tr>
<td class="left">{_ &#8220;Fun&#8221;: true, &#8220;Amt&#8221;: -2}</td>
<td class="left">0xbf6346756ef563416d7421ff</td>
</tr>
</tbody>
</table>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#jump-table" id="jump-table">Jump Table</a>
</h1>
<p id="rfc.section.B.p.1">For brevity, this jump table does not show initial bytes that are reserved for future extension. It also only shows a selection of the initial bytes that can be used for optional features.  (All unsigned integers are in network byte order.)</p>
<div id="rfc.table.5"></div>
<div id="jumptable"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Jump Table for Initial Byte</caption>
<thead><tr>
<th class="left">Byte</th>
<th class="left">Structure/Semantics</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x00..0x17</td>
<td class="left">Integer 0x00..0x17 (0..23)</td>
</tr>
<tr>
<td class="left">0x18</td>
<td class="left">Unsigned integer (one-byte uint8_t follows)</td>
</tr>
<tr>
<td class="left">0x19</td>
<td class="left">Unsigned integer (two-byte uint16_t follows)</td>
</tr>
<tr>
<td class="left">0x1a</td>
<td class="left">Unsigned integer (four-byte uint32_t follows)</td>
</tr>
<tr>
<td class="left">0x1b</td>
<td class="left">Unsigned integer (eight-byte uint64_t follows)</td>
</tr>
<tr>
<td class="left">0x20..0x37</td>
<td class="left">Negative integer -1-0x00..-1-0x17 (-1..-24)</td>
</tr>
<tr>
<td class="left">0x38</td>
<td class="left">Negative integer -1-n (one-byte uint8_t for n follows)</td>
</tr>
<tr>
<td class="left">0x39</td>
<td class="left">Negative integer -1-n (two-byte uint16_t for n follows)</td>
</tr>
<tr>
<td class="left">0x3a</td>
<td class="left">Negative integer -1-n (four-byte uint32_t for n follows)</td>
</tr>
<tr>
<td class="left">0x3b</td>
<td class="left">Negative integer -1-n (eight-byte uint64_t for n follows)</td>
</tr>
<tr>
<td class="left">0x40..0x57</td>
<td class="left">byte string (0x00..0x17 bytes follow)</td>
</tr>
<tr>
<td class="left">0x58</td>
<td class="left">byte string (one-byte uint8_t for n, and then n bytes follow)</td>
</tr>
<tr>
<td class="left">0x59</td>
<td class="left">byte string (two-byte uint16_t for n, and then n bytes follow)</td>
</tr>
<tr>
<td class="left">0x5a</td>
<td class="left">byte string (four-byte uint32_t for n, and then n bytes follow)</td>
</tr>
<tr>
<td class="left">0x5b</td>
<td class="left">byte string (eight-byte uint64_t for n, and then n bytes follow)</td>
</tr>
<tr>
<td class="left">0x5f</td>
<td class="left">byte string, byte strings follow, terminated by &#8220;break&#8221;</td>
</tr>
<tr>
<td class="left">0x60..0x77</td>
<td class="left">UTF-8 string (0x00..0x17 bytes follow)</td>
</tr>
<tr>
<td class="left">0x78</td>
<td class="left">UTF-8 string (one-byte uint8_t for n, and then n bytes follow)</td>
</tr>
<tr>
<td class="left">0x79</td>
<td class="left">UTF-8 string (two-byte uint16_t for n, and then n bytes follow)</td>
</tr>
<tr>
<td class="left">0x7a</td>
<td class="left">UTF-8 string (four-byte uint32_t for n, and then n bytes follow)</td>
</tr>
<tr>
<td class="left">0x7b</td>
<td class="left">UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)</td>
</tr>
<tr>
<td class="left">0x7f</td>
<td class="left">UTF-8 string, UTF-8 strings follow, terminated by &#8220;break&#8221;</td>
</tr>
<tr>
<td class="left">0x80..0x97</td>
<td class="left">array (0x00..0x17 data items follow)</td>
</tr>
<tr>
<td class="left">0x98</td>
<td class="left">array (one-byte uint8_t for n, and then n data items follow)</td>
</tr>
<tr>
<td class="left">0x99</td>
<td class="left">array (two-byte uint16_t for n, and then n data items follow)</td>
</tr>
<tr>
<td class="left">0x9a</td>
<td class="left">array (four-byte uint32_t for n, and then n data items follow)</td>
</tr>
<tr>
<td class="left">0x9b</td>
<td class="left">array (eight-byte uint64_t for n, and then n data items follow)</td>
</tr>
<tr>
<td class="left">0x9f</td>
<td class="left">array, data items follow, terminated by &#8220;break&#8221;</td>
</tr>
<tr>
<td class="left">0xa0..0xb7</td>
<td class="left">map (0x00..0x17 pairs of data items follow)</td>
</tr>
<tr>
<td class="left">0xb8</td>
<td class="left">map (one-byte uint8_t for n, and then n pairs of data items follow)</td>
</tr>
<tr>
<td class="left">0xb9</td>
<td class="left">map (two-byte uint16_t for n, and then n pairs of data items follow)</td>
</tr>
<tr>
<td class="left">0xba</td>
<td class="left">map (four-byte uint32_t for n, and then n pairs of data items follow)</td>
</tr>
<tr>
<td class="left">0xbb</td>
<td class="left">map (eight-byte uint64_t for n, and then n pairs of data items follow)</td>
</tr>
<tr>
<td class="left">0xbf</td>
<td class="left">map, pairs of data items follow, terminated by &#8220;break&#8221;</td>
</tr>
<tr>
<td class="left">0xc0</td>
<td class="left">Text-based date/time (data item follows; see <a href="#datetimesect" class="xref">Section 2.4.1</a>)</td>
</tr>
<tr>
<td class="left">0xc1</td>
<td class="left">Epoch-based date/time (data item follows; see <a href="#datetimesect" class="xref">Section 2.4.1</a>)</td>
</tr>
<tr>
<td class="left">0xc2</td>
<td class="left">Positive bignum (data item &#8220;byte string&#8221; follows)</td>
</tr>
<tr>
<td class="left">0xc3</td>
<td class="left">Negative bignum (data item &#8220;byte string&#8221; follows)</td>
</tr>
<tr>
<td class="left">0xc4</td>
<td class="left">Decimal Fraction (data item &#8220;array&#8221; follows; see <a href="#fractions" class="xref">Section 2.4.3</a>)</td>
</tr>
<tr>
<td class="left">0xc5</td>
<td class="left">Bigfloat (data item &#8220;array&#8221; follows; see <a href="#fractions" class="xref">Section 2.4.3</a>)</td>
</tr>
<tr>
<td class="left">0xc6..0xd4</td>
<td class="left">(tagged item)</td>
</tr>
<tr>
<td class="left">0xd5..0xd7</td>
<td class="left">Expected Conversion (data item follows; see <a href="#convexpect" class="xref">Section 2.4.4.2</a>)</td>
</tr>
<tr>
<td class="left">0xd8..0xdb</td>
<td class="left">(more tagged items, 1/2/4/8 bytes and then a data item follow)</td>
</tr>
<tr>
<td class="left">0xe0..0xf3</td>
<td class="left">(simple value)</td>
</tr>
<tr>
<td class="left">0xf4</td>
<td class="left">False</td>
</tr>
<tr>
<td class="left">0xf5</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">0xf6</td>
<td class="left">Null</td>
</tr>
<tr>
<td class="left">0xf7</td>
<td class="left">Undefined</td>
</tr>
<tr>
<td class="left">0xf8</td>
<td class="left">(simple value, one byte follows)</td>
</tr>
<tr>
<td class="left">0xf9</td>
<td class="left">Half-Precision Float (two-byte IEEE 754)</td>
</tr>
<tr>
<td class="left">0xfa</td>
<td class="left">Single-Precision Float (four-byte IEEE 754)</td>
</tr>
<tr>
<td class="left">0xfb</td>
<td class="left">Double-Precision Float (eight-byte IEEE 754)</td>
</tr>
<tr>
<td class="left">0xff</td>
<td class="left">&#8220;break&#8221; stop code</td>
</tr>
</tbody>
</table>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#pseudocode" id="pseudocode">Pseudocode</a>
</h1>
<p id="rfc.section.C.p.1">The well-formedness of a CBOR item can be checked by the pseudocode in <a href="#pseudo" class="xref">Figure 1</a>.  The data is well-formed if and only if:</p>
<p></p>

<ul>
<li>the pseudocode does not &#8220;fail&#8221;;</li>
<li>after execution of the pseudocode, no bytes are left in the input (except in streaming applications)</li>
</ul>
<p id="rfc.section.C.p.3">The pseudocode has the following prerequisites:</p>
<p></p>

<ul>
<li>take(n) reads n bytes from the input data and returns them as a byte string.  If n bytes are no longer available, take(n) fails.</li>
<li>uint() converts a byte string into an unsigned integer by interpreting the byte string in network byte order.</li>
<li>Arithmetic works as in C.</li>
<li>All variables are unsigned integers of sufficient range.</li>
</ul>
<div id="rfc.figure.1"></div>
<div id="pseudo"></div>
<pre>
well_formed (breakable = false) {
  // process initial bytes
  ib = uint(take(1));
  mt = ib &gt;&gt; 5;
  val = ai = ib &amp; 0x1f;
  switch (ai) {
    case 24: val = uint(take(1)); break;
    case 25: val = uint(take(2)); break;
    case 26: val = uint(take(4)); break;
    case 27: val = uint(take(8)); break;
    case 28: case 29: case 30: fail();
    case 31:
      return well_formed_indefinite(mt, breakable);
  }
  // process content
  switch (mt) {
    // case 0, 1, 7 do not have content; just use val
    case 2: case 3: take(val); break; // bytes/UTF-8
    case 4: for (i = 0; i &lt; val; i++) well_formed(); break;
    case 5: for (i = 0; i &lt; val*2; i++) well_formed(); break;
    case 6: well_formed(); break;     // 1 embedded data item
  }
  return mt;                    // finite data item
}

well_formed_indefinite(mt, breakable) {
  switch (mt) {
    case 2: case 3:
      while ((it = well_formed(true)) != -1)
        if (it != mt)           // need finite embedded
          fail();               //    of same type
      break;
    case 4: while (well_formed(true) != -1); break;
    case 5: while (well_formed(true) != -1) well_formed(); break;
    case 7:
      if (breakable)
        return -1;              // signal break out
      else fail();              // no enclosing indefinite
    default: fail();            // wrong mt
  }
  return 0;                     // no break out
}
</pre>
<p class="figure">Figure 1: Pseudocode for Well-Formedness Check</p>
<p id="rfc.section.C.p.5">Note that the remaining complexity of a complete CBOR decoder is about presenting data that has been parsed to the application in an appropriate form.</p>
<p id="rfc.section.C.p.6">Major types 0 and 1 are designed in such a way that they can be encoded in C from a signed integer without actually doing an if-then-else for positive/negative (<a href="#branchless" class="xref">Figure 2</a>).  This uses the fact that (-1-n), the transformation for major type 1, is the same as ~n (bitwise complement) in C unsigned arithmetic; ~n can then be expressed as (-1)^n for the negative case, while 0^n leaves n unchanged for non-negative.  The sign of a number can be converted to -1 for negative and 0 for non-negative (0 or positive) by arithmetic-shifting the number by one bit less than the bit length of the number (for example, by 63 for 64-bit numbers).</p>
<div id="rfc.figure.2"></div>
<div id="branchless"></div>
<pre>
void encode_sint(int64_t n) {
  uint64t ui = n &gt;&gt; 63;    // extend sign to whole length
  mt = ui &amp; 0x20;          // extract major type
  ui ^= n;                 // complement negatives
  if (ui &lt; 24)
    *p++ = mt + ui;
  else if (ui &lt; 256) {
    *p++ = mt + 24;
    *p++ = ui;
  } else
       ...
</pre>
<p class="figure">Figure 2: Pseudocode for Encoding a Signed Integer</p>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#half-precision" id="half-precision">Half-Precision</a>
</h1>
<p id="rfc.section.D.p.1">As half-precision floating-point numbers were only added to IEEE 754 in 2008, today&#8217;s programming platforms often still only have limited support for them.  It is very easy to include at least decoding support for them even without such support.  An example of a small decoder for half-precision floating-point numbers in the C language is shown in <a href="#decode-half-c" class="xref">Figure 3</a>.  A similar program for Python is in <a href="#decode-half-py" class="xref">Figure 4</a>; this code assumes that the 2-byte value has already been decoded as an (unsigned short) integer in network byte order (as would be done by the pseudocode in <a href="#pseudocode" class="xref">Appendix C</a>).</p>
<div id="rfc.figure.3"></div>
<div id="decode-half-c"></div>
<pre>
#include &lt;math.h&gt;

double decode_half(unsigned char *halfp) {
  int half = (halfp[0] &lt;&lt; 8) + halfp[1];
  int exp = (half &gt;&gt; 10) &amp; 0x1f;
  int mant = half &amp; 0x3ff;
  double val;
  if (exp == 0) val = ldexp(mant, -24);
  else if (exp != 31) val = ldexp(mant + 1024, exp - 25);
  else val = mant == 0 ? INFINITY : NAN;
  return half &amp; 0x8000 ? -val : val;
}
</pre>
<p class="figure">Figure 3: C Code for a Half-Precision Decoder</p>
<div id="rfc.figure.4"></div>
<div id="decode-half-py"></div>
<pre>
import struct
from math import ldexp

def decode_single(single):
    return struct.unpack("!f", struct.pack("!I", single))[0]

def decode_half(half):
    valu = (half &amp; 0x7fff) &lt;&lt; 13 | (half &amp; 0x8000) &lt;&lt; 16
    if ((half &amp; 0x7c00) != 0x7c00):
        return ldexp(decode_single(valu), 112)
    return decode_single(valu | 0x7f800000)
</pre>
<p class="figure">Figure 4: Python Code for a Half-Precision Decoder</p>
<h1 id="rfc.appendix.E">
<a href="#rfc.appendix.E">Appendix E.</a> <a href="#comparison-app" id="comparison-app">Comparison of Other Binary Formats to CBOR&#8217;s Design Objectives</a>
</h1>
<p id="rfc.section.E.p.1">The proposal for CBOR follows a history of binary formats that is as long as the history of computers themselves. Different formats have had different objectives. In most cases, the objectives of the format were never stated, although they can sometimes be implied by the context where the format was first used. Some formats were meant to be universally usable, although history has proven that no binary format meets the needs of all protocols and applications.</p>
<p id="rfc.section.E.p.2">CBOR differs from many of these formats due to it starting with a set of objectives and attempting to meet just those. This section compares a few of the dozens of formats with CBOR&#8217;s objectives in order to help the reader decide if they want to use CBOR or a different format for a particular protocol or application.</p>
<p id="rfc.section.E.p.3">Note that the discussion here is not meant to be a criticism of any format: to the best of our knowledge, no format before CBOR was meant to cover CBOR&#8217;s objectives in the priority we have assigned them.  A brief recap of the objectives from <a href="#objectives" class="xref">Section 1.1</a> is:</p>
<p></p>

<ol>
<li>unambiguous encoding of most common data formats from Internet standards</li>
<li>code compactness for encoder or decoder</li>
<li>no schema description needed</li>
<li>reasonably compact serialization</li>
<li>applicability to constrained and unconstrained applications</li>
<li>good JSON conversion</li>
<li>extensibility</li>
</ol>
<h1 id="rfc.appendix.E.1">
<a href="#rfc.appendix.E.1">E.1.</a> <a href="#asn1-der-ber-and-per" id="asn1-der-ber-and-per">ASN.1 DER, BER, and PER</a>
</h1>
<p><a href="#ASN.1" class="xref">[ASN.1]</a> has many serializations. In the IETF, DER and BER are the most common. The serialized output is not particularly compact for many items, and the code needed to decode numeric items can be complex on a constrained device.</p>
<p id="rfc.section.E.1.p.2">Few (if any) IETF protocols have adopted one of the several variants of Packed Encoding Rules (PER).  There could be many reasons for this, but one that is commonly stated is that PER makes use of the schema even for parsing the surface structure of the data stream, requiring significant tool support.  There are different versions of the ASN.1 schema language in use, which has also hampered adoption.</p>
<h1 id="rfc.appendix.E.2">
<a href="#rfc.appendix.E.2">E.2.</a> <a href="#messagepack" id="messagepack">MessagePack</a>
</h1>
<p><a href="#MessagePack" class="xref">[MessagePack]</a> is a concise, widely implemented counted binary serialization format, similar in many properties to CBOR, although somewhat less regular.  While the data model can be used to represent JSON data, MessagePack has also been used in many remote procedure call (RPC) applications and for long-term storage of data.</p>
<p id="rfc.section.E.2.p.2">MessagePack has been essentially stable since it was first published around 2011; it has not yet had a transition.  The evolution of MessagePack is impeded by an imperative to maintain complete backwards compatibility with existing stored data, while only few bytecodes are still available for extension.  Repeated requests over the years from the MessagePack user community to separate out binary and text strings in the encoding recently have led to an extension proposal that would leave MessagePack&#8217;s &#8220;raw&#8221; data ambiguous between its usages for binary and text data. The extension mechanism for MessagePack remains unclear.</p>
<h1 id="rfc.appendix.E.3">
<a href="#rfc.appendix.E.3">E.3.</a> <a href="#bson" id="bson">BSON</a>
</h1>
<p><a href="#BSON" class="xref">[BSON]</a> is a data format that was developed for the storage of JSON-like maps (JSON objects) in the MongoDB database.  Its major distinguishing feature is the capability for in-place update, foregoing a compact representation.  BSON uses a counted representation except for map keys, which are null-byte terminated.  While BSON can be used for the representation of JSON-like objects on the wire, its specification is dominated by the requirements of the database application and has become somewhat baroque. The status of how BSON extensions will be implemented remains unclear.</p>
<h1 id="rfc.appendix.E.4">
<a href="#rfc.appendix.E.4">E.4.</a> <a href="#ubjson" id="ubjson">UBJSON</a>
</h1>
<p><a href="#UBJSON" class="xref">[UBJSON]</a> has a design goal to make JSON faster and somewhat smaller, using a binary format that is limited to exactly the data model JSON uses.  Thus, there is expressly no intention to support, for example, binary data; however, there is a &#8220;high-precision number&#8221;, expressed as a character string in JSON syntax.  UBJSON is not optimized for code compactness, and its type byte coding is optimized for human recognition and not for compact representation of native types such as small integers.  Although UBJSON is mostly counted, it provides a reserved &#8220;unknown-length&#8221; value to support streaming of arrays and maps (JSON objects).  Within these containers, UBJSON also has a &#8220;Noop&#8221; type for padding.</p>
<h1 id="rfc.appendix.E.5">
<a href="#rfc.appendix.E.5">E.5.</a> <a href="#msdtp-rfc-713" id="msdtp-rfc-713">MSDTP: RFC 713</a>
</h1>
<p id="rfc.section.E.5.p.1">Message Services Data Transmission (MSDTP) is a very early example of a compact message format; it is described in <a href="#RFC0713" class="xref">[RFC0713]</a>, written in 1976. It is included here for its historical value, not because it was ever widely used.</p>
<h1 id="rfc.appendix.E.6">
<a href="#rfc.appendix.E.6">E.6.</a> <a href="#conciseness-on-the-wire" id="conciseness-on-the-wire">Conciseness on the Wire</a>
</h1>
<p id="rfc.section.E.6.p.1">While CBOR&#8217;s design objective of code compactness for encoders and decoders is a higher priority than its objective of conciseness on the wire, many people focus on the wire size. <a href="#concise" class="xref">Table 6</a> shows some encoding examples for the simple nested array [1, [2, 3]]; where some form of indefinite-length encoding is supported by the encoding, [_&#160;1, [2, 3]] (indefinite length on the outer array) is also shown.</p>
<div id="rfc.table.6"></div>
<div id="concise"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Examples for Different Levels of Conciseness</caption>
<thead><tr>
<th class="left">Format</th>
<th class="left">[1, [2, 3]]</th>
<th class="left">[_ 1, [2, 3]]</th>
</tr></thead>
<tbody>
<tr>
<td class="left">RFC 713</td>
<td class="left">c2 05 81 c2 02 82 83</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">ASN.1 BER</td>
<td class="left">30 0b 02 01 01 30 06 02 01 02 02 01 03</td>
<td class="left">30 80 02 01 01 30 06 02 01 02 02 01 03 00 00</td>
</tr>
<tr>
<td class="left">MessagePack</td>
<td class="left">92 01 92 02 03</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">BSON</td>
<td class="left">22 00 00 00 10 30 00 01 00 00 00 04 31 00 13 00 00 00 10 30 00 02 00 00 00 10 31 00 03 00 00 00 00 00</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">UBJSON</td>
<td class="left">61 02 42 01 61 02 42 02 42 03</td>
<td class="left">61 ff 42 01 61 02 42 02 42 03 45</td>
</tr>
<tr>
<td class="left">CBOR</td>
<td class="left">82 01 82 02 03</td>
<td class="left">9f 01 82 02 03 ff</td>
</tr>
</tbody>
</table>
<h1 id="rfc.appendix.F">
<a href="#rfc.appendix.F">Appendix F.</a> <a href="#changes-from-rfc-7049" id="changes-from-rfc-7049">Changes from RFC 7049</a>
</h1>
<p id="rfc.section.F.p.1">The following is a list of known changes from RFC 7049. This list is non-authoritative. It is meant to help reviewers see the significant differences.</p>
<p></p>

<ul>
<li>Updated reference for [RFC4267] to <a href="#RFC7159" class="xref">[RFC7159]</a> in many places</li>
<li>Updated reference for [CNN-TERMS] to <a href="#RFC7228" class="xref">[RFC7228]</a>
</li>
<li>Added a comment to the last example in Section 2.2.1 (added &#8220;Second value&#8221;)</li>
<li>Fixed a bug in the example in Section 2.4.2 (&#8220;29&#8221; -&gt; &#8220;49&#8221;)</li>
<li>Fixed a bug in the last paragraph of Section 3.6 (&#8220;0b000_11101&#8221; -&gt; &#8220;0b000_11001&#8221;)</li>
</ul>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Carsten Bormann</span> 
	  <span class="n hidden">
		<span class="family-name">Bormann</span>
	  </span>
	</span>
	<span class="org vcardline">Universitaet Bremen TZI</span>
	<span class="adr">
	  <span class="vcardline">Postfach 330440</span>

	  <span class="vcardline">
		<span class="locality">D-28359 Bremen</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">Phone: +49-421-218-63921</span>

<span class="vcardline">EMail: <a href="mailto:cabo@tzi.org">cabo@tzi.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Paul Hoffman</span> 
	  <span class="n hidden">
		<span class="family-name">Hoffman</span>
	  </span>
	</span>
	<span class="org vcardline">ICANN</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:paul.hoffman@icann.org">paul.hoffman@icann.org</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/cbor-wg/CBORbis">Fork me on GitHub</a></div></div>
</body>
</html>
